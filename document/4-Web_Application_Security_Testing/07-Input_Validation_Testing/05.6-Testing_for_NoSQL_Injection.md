# Тестирование на инъекцию NoSQL

## Резюме

Базы данных NoSQL обеспечивают более слабые ограничения согласованности, чем традиционные базы данных SQL. Требуя меньшего количества реляционных ограничений и проверок согласованности, базы данных NoSQL часто предлагают преимущества производительности и масштабирования. Тем не менее, эти базы данных все еще потенциально уязвимы для атак инъекций, даже если они не используют традиционный синтаксис SQL. Потому что эти атаки впрыска NoSQL могут выполняться в пределах a [procedural language](https://en.wikipedia.org/wiki/Procedural_programming), а не в [declarative SQL language](https://en.wikipedia.org/wiki/Declarative_programming), потенциальные воздействия больше, чем у традиционного SQL-инъекции.

Вызовы базы данных NoSQL записываются на языке программирования приложения, настраиваемом вызове API или форматируются в соответствии с общим соглашением (например, `XML`, `JSON`, `LINQ`, etc). Вредоносные входные данные, нацеленные на эти спецификации, могут не вызывать проверки в первую очередь при дезинфекции приложений. Например, отфильтровывание общих специальных символов HTML, таких как `< > & ;` не будет препятствовать атакам на JSON API, где есть специальные символы `/ { } :`.

Tздесь сейчас более 150 [NoSQL databases available](http://nosql-database.org) для использования в приложении, предоставляя API на разных языках и моделях отношений. Каждый предлагает различные функции и ограничения. Поскольку между ними нет общего языка, пример кода инъекции не будет применяться во всех базах данных NoSQL. По этой причине любой, кто тестирует атаки на инъекции NoSQL, должен будет ознакомиться с синтаксисом, моделью данных и базовым языком программирования, чтобы создать конкретные тесты.

Атаки впрыска NoSQL могут выполняться в различных областях приложения, чем традиционная инъекция SQL. Если в движке базы данных будет выполняться SQL-инъекция, варианты NoSQL могут выполняться в течение уровня приложения или уровня базы данных, в зависимости от используемого API NoSQL и модели данных. Обычно атаки на инъекции NoSQL выполняются, когда строка атаки анализируется, оценивается или объединяется в вызов API NoSQL.

Дополнительные временные атаки могут иметь отношение к отсутствию проверок параллелизма в базе данных NoSQL. Они не включены в тестирование на инъекцию. На момент написания MongoDB является наиболее широко используемой базой данных NoSQL, поэтому все примеры будут иметь API MongoDB.

## Как проверить

### Тестирование на уязвимости инъекций NoSQL в MongoDB

MongoDB API ожидает BSON (Binary JSON) вызывает и включает в себя безопасный инструмент сборки запросов BSON. Однако, согласно документации MongoDB - несериализованный JSON и [JavaScript expressions](https://docs.mongodb.org/manual/faq/developers/#javascript) разрешены в нескольких альтернативных параметрах запроса. Наиболее часто используемый вызов API, позволяющий произвольный ввод JavaScript, является `$where` оператор.

МонгоДБ `$where` operator typically используется как простой фильтр или проверка, как это в SQL .

`db.myCollection.find( { $where: "this.credits`` ``==`` ``this.debits" } );`

При желании JavaScript также оценивается, чтобы позволить более продвинутые условия.

`db.myCollection.find( { $where: function() { return obj.credits - obj.debits < 0; } } );`

### Пример 1

Если злоумышленник смог манипулировать данными, передаваемыми в оператор `$ where`, этот злоумышленник может включить произвольный JavaScript для оценки как часть запроса MongoDB. Пример уязвимости раскрывается в следующем коде, если пользовательский ввод передается непосредственно в запрос MongoDB без дезинфекции.

`db.myCollection.find( { active: true, $where: function() { return obj.credits - obj.debits < $userInput; } } );;`

Как и при тестировании других типов инъекций, не нужно полностью использовать уязвимость, чтобы продемонстрировать проблему. Вводя специальные символы, относящиеся к целевому языку API, и наблюдая за результатами, тестер может определить, правильно ли приложение продезинфицировало ввод. Например, в MongoDB, если строка, содержащая любой из следующих специальных символов, была передана без анализа, это вызовет ошибку базы данных.

`' " \ ; { }`

При обычном вводе SQL аналогичная уязвимость позволит злоумышленнику выполнять произвольные команды SQL - выставляет или манипулирует данными по желанию. Однако, поскольку JavaScript является полнофункциональным языком, это не только позволяет злоумышленнику манипулировать данными, но и запускать произвольный код. Например, вместо того, чтобы просто вызывать ошибку при тестировании, полный эксплойт будет использовать специальные символы для создания допустимого JavaScript.

Этот ввод `0;var date=new Date(); do{curDate = new Date();}while(curDate-date<10000)` вставленный в `$ userInput` в приведенном выше примере кода приведет к выполнению следующей функции JavaScript. Эта конкретная строка атаки будет иметь место для выполнения всего экземпляра MongoDB при 100% использовании процессора в течение 10 секунд.

`function() { return obj.credits - obj.debits < 0;var date=new Date(); do{curDate = new Date();}while(curDate-date<10000); }`

Даже если входные данные, используемые в запросах, полностью продезинфицированы или параметризованы, существует альтернативный путь, по которому можно инициировать инъекцию NoSQL. Многие экземпляры NoSQL имеют свои собственные зарезервированные имена переменных, независимо от языка программирования приложения.

Например, в MongoDB сам синтаксис `$ where` является зарезервированным оператором запросов. Он должен быть передан в запрос точно так, как показано; любое изменение может привести к ошибке базы данных. Однако, поскольку `$ where` также является допустимым именем переменной PHP, злоумышленник может вставить код в запрос, создав переменную PHP с именем `$ where`. Документация PHP MongoDB явно предупреждает разработчиков:

Убедитесь, что для всех операторов специальных запросов (начиная с `$`) вы используете одинарные кавычки, чтобы PHP не пытался заменить `$ exists `со значением переменной `$ exists`.

Даже если запрос не зависел от пользовательского ввода, такого как следующий пример, злоумышленник может использовать MongoDB, заменив оператора вредоносными данными.

`db.myCollection.find( { $where: function() { return obj.credits - obj.debits < 0; } } );`

Один из способов потенциально назначить данные переменным PHP - через загрязнение параметров HTTP (see: [Testing for HTTP Parameter pollution](04-Testing_for_HTTP_Parameter_Pollution.md)). Создав переменную с именем `$ where` через загрязнение параметра, можно вызвать ошибку MongoDB, указывающую, что запрос больше не действителен. Любое значение `$ where`, кроме самой строки `$ where`, должно быть достаточным для демонстрации уязвимости. Злоумышленник разработает полный эксплойт, вставив следующее:

`$where: function() { //arbitrary JavaScript here }`

## References

### Injection Payloads

- [Injection payload wordlist with examples of NoSQL Injection for MongoDB](https://github.com/cr0hn/nosqlinjection_wordlists)

### Whitepapers

- [Bryan Sullivan from Adobe: "NoSQL, But Even Less Security"](https://blogs.adobe.com/asset/files/2011/04/NoSQL-But-Even-Less-Security.pdf)
- [Erlend from Bekk Consulting: "[Security] NOSQL-injection"](https://erlend.oftedal.no/blog/?blogid=110)
- [Felipe Aragon from Syhunt: "NoSQL/SSJS Injection"](http://www.syhunt.com/en/?n=Articles.NoSQLInjection)
- [MongoDB Documentation: "How does MongoDB address SQL or Query injection?"](https://docs.mongodb.org/manual/faq/developers/#how-does-mongodb-address-sql-or-query-injection)
- [PHP Documentation: "MongoCollection::find"](https://www.php.net/manual/ro/mongocollection.find.php)
- [Hacking NodeJS and MongoDB](https://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb.html)
- [Attacking NodeJS and MongoDB](https://blog.websecurify.com/2014/08/attacks-nodejs-and-mongodb-part-to.html)
