# Тестирование на загрязнение параметров HTTP

| ID |
| ------------- |
| WSTG-INPV-04 |

## Резюме

Параметр HTTP Pollution проверяет реакцию приложений на получение нескольких параметров HTTP с одним и тем же именем; например, если параметр `имя пользователя` включен в параметры GET или POST дважды.

Поставка нескольких параметров HTTP с одним и тем же именем может привести к тому, что приложение будет интерпретировать значения непредвиденным образом. Используя эти эффекты, злоумышленник может обойти проверку ввода, вызвать ошибки приложения или изменить значения внутренних переменных. Поскольку загрязнение параметров HTTP (вкратце * HPP *) влияет на строительный блок всех веб-технологий, существуют атаки на сервер и на стороне клиента.

Текущие стандарты HTTP не включают руководство о том, как интерпретировать несколько входных параметров с одним и тем же именем. Например, [RFC 3986](https://www.ietf.org/rfc/rfc3986.txt) просто определяет термин *Query String* как серия пар полевых значений и [RFC 2396](https://www.ietf.org/rfc/rfc2396.txt) определяет классы обращенных и незарезервированных символов строки запроса. Без стандартного стандарта компоненты веб-приложений обрабатывают этот краевой корпус различными способами (подробности см. В таблице ниже).

Само по себе это не обязательно свидетельствует об уязвимости. Однако, если разработчик не знает о проблеме, наличие дублированных параметров может привести к аномальному поведению в приложении, которое может быть потенциально использовано злоумышленником. Как часто в безопасности, неожиданное поведение является обычным источником слабых сторон, которые могут привести к атакам загрязнения параметров HTTP в этом случае. Чтобы лучше представить этот класс уязвимостей и результаты атак ГЭС, интересно проанализировать некоторые реальные примеры, которые были обнаружены в прошлом.

### Проверка ввода и обход фильтров

В 2009 году, сразу после публикации первого исследования HTTP Parameter Pollution, метод получил внимание сообщества безопасности как возможный способ обойти брандмауэры веб-приложений.

Один из этих недостатков, влияющих *ModSecurity SQL Injection Core Rules*, представляет собой прекрасный пример несоответствия импеданса между приложениями и фильтрами. Фильтр ModSecurity будет правильно применять список отказов для следующей строки: `select 1,2,3 from table`, таким образом блокируя этот пример URL от обработки веб-сервером: `/index.aspx?page=select 1,2,3 from table`. Однако, используя конкатенацию нескольких параметров HTTP, злоумышленник может заставить сервер приложения конкатенации строки после того, как фильтр ModSecurity уже принял ввод. В качестве примера, URL `/index.aspx?page=select 1&page=2,3` из таблицы не будет запускать фильтр ModSecurity, но прикладной уровень будет объединять вход обратно в полную вредоносную строку.

Оказалось, что другая уязвимость HPP повлияла *Apple Cups*, известная система печати, используемая многими системами UNIX. Используя HPP, злоумышленник может легко вызвать уязвимость межсайтового скриптинга, используя следующий URL: `http://127.0.0.1:631/admin/?kerberos=onmouseover=alert(1)&kerberos`. Контрольную точку проверки приложения можно обойти, добавив дополнительный аргумент `kerberos`, имеющий допустимую строку (например,. пустая строка). Поскольку контрольная точка проверки будет рассматривать только второе явление, первый параметр `kerberos` не был должным образом продезинфицирован перед использованием для генерации динамического содержимого HTML. Успешная эксплуатация приведет к выполнению кода JavaScript в контексте веб-сайта хостинга.

### Обход аутентификации

Еще более критическая уязвимость HPP была обнаружена в *Blogger*, популярная платформа для блогов. Ошибка позволила злоумышленникам взять на себя ответственность за блог жертвы, используя следующий HTTP-запрос (`https://www.blogger.com/add-authors.do`):

```html
POST /add-authors.do HTTP/1.1
[...]

security_token=attackertoken&blogID=attackerblogidvalue&blogID=victimblogidvalue&authorsList=goldshlager19test%40gmail.com(attacker email)&ok=Invite
```

Недостаток заключался в механизме аутентификации, используемом веб-приложением, поскольку проверка безопасности выполнялась для первого параметра `blogID`, тогда как фактическая операция использовала второе вхождение.

### Ожидаемое поведение со стороны Application Server

Следующая таблица иллюстрирует, как различные веб-технологии ведут себя при наличии нескольких вхождений одного и того же параметра HTTP.

Учитывая URL и строку запроса: `http://example.com/?color=red&color=blue`

  | Web Application Server Backend | Parsing Result | Example |
  |--------------------------------|----------------|--------|
  | ASP.NET / IIS | All occurrences concatenated with a comma |  color=red,blue |
  | ASP / IIS     | All occurrences concatenated with a comma | color=red,blue |
  | .NET Core 3.1 / Kestrel | All occurrences concatenated with a comma | color=red,blue |
  | .NET 5 / Kestrel | All occurrences concatenated with a comma | color=red,blue |
  | PHP / Apache  | Last occurrence only | color=blue |
  | PHP / Zeus | Last occurrence only | color=blue |
  | JSP, Servlet / Apache Tomcat | First occurrence only | color=red |
  | JSP, Servlet / Oracle Application Server 10g | First occurrence only | color=red |
  | JSP, Servlet / Jetty  | First occurrence only | color=red |
  | IBM Lotus Domino | Last occurrence only | color=blue |
  | IBM HTTP Server | First occurrence only | color=red |
  | node.js / express | First occurence only | color=red |
  | mod_perl, libapreq2 / Apache | First occurrence only | color=red |
  | Perl CGI / Apache | First occurrence only | color=red |
  | mod_wsgi (Python) / Apache | First occurrence only | color=red |
  | Python / Zope | All occurrences in List data type | color=['red','blue'] |

(source: [Appsec EU 2009 Carettoni & Paola](https://owasp.org/www-pdf-archive/AppsecEU09_CarettoniDiPaola_v0.8.pdf))

## Цели теста

- Определите бэкэнд и используемый метод синтаксического анализа.
- Оцените точки впрыска и попробуйте обойти фильтры ввода, используя HPP .

## Как проверить

К счастью, поскольку назначение параметров HTTP обычно выполняется через сервер веб-приложений, а не сам код приложения, тестирование реакции на загрязнение параметров должно быть стандартным для всех страниц и действий. Однако, поскольку необходимы глубокие знания бизнес-логики, тестирование HPP требует ручного тестирования. Автоматические инструменты могут лишь частично помочь аудиторам, поскольку они, как правило, генерируют слишком много ложных срабатываний. Кроме того, HPP может проявляться в клиентских и серверных компонентах.

### HPP на стороне сервера

Чтобы проверить наличие уязвимостей HPP, определите любую форму или действие, которое позволяет вводить данные, предоставляемые пользователем. Параметры строки запроса в HTTP-запросах GET легко настраиваются в панели навигации браузера. Если действие формы отправляет данные через POST, тестер должен будет использовать перехватывающий прокси-сервер для подделки данных POST при их отправке на сервер. Определив конкретный входной параметр для тестирования, можно редактировать данные GET или POST, перехватывая запрос, или изменять строку запроса после загрузки страницы ответа. Чтобы проверить наличие уязвимостей HPP, просто добавьте один и тот же параметр к данным GET или POST, но с другим назначенным значением.

Например: если тестируется параметр `search_string` в строке запроса, URL-адрес запроса будет включать это имя и значение параметра:

```text
http://example.com/?search_string=kittens
```

Конкретный параметр может быть скрыт среди нескольких других параметров, но подход тот же; оставьте другие параметры на месте и добавьте дубликат :

```text
http://example.com/?mode=guest&search_string=kittens&num_results=100
```

Добавить тот же параметр с другим значением:

```text
http://example.com/?mode=guest&search_string=kittens&num_results=100&search_string=puppies
```

и отправить новый запрос.

Проанализируйте страницу ответа, чтобы определить, какие значения были проанализированы. В приведенном выше примере результаты поиска могут показывать `kittens`, `puppies`, некоторую комбинацию обоих (` kittens, puppies `или` kittens ~ puppies `или` ['kittens', 'puppies'] '), может дать пустой результат или страницу ошибки.

Такое поведение, будь то использование первого, последнего или комбинации входных параметров с одним и тем же именем, весьма вероятно, будет согласованным для всего приложения. Независимо от того, показывает ли это поведение по умолчанию потенциальную уязвимость, зависит от конкретной проверки входных данных и фильтрации, специфичной для конкретного приложения. Как правило: если на отдельных входах достаточно существующих входных проверок и других механизмов безопасности, и если сервер назначает только первые или последние загрязненные параметры, то загрязнение параметров не обнаруживает уязвимости. Если дублирующие параметры объединяются, разные компоненты веб-приложений используют разные вхождения или тестирование генерирует ошибку, существует повышенная вероятность использования параметров загрязнения для устранения уязвимостей безопасности.

Более глубокий анализ потребует трех HTTP-запросов для каждого параметра HTTP:

1. Отправьте HTTP-запрос, содержащий стандартное имя и значение параметра, и запишите HTTP-ответ. Например. `page?par1=val1`
2. Замените значение параметра на подделанное значение, отправьте и запишите ответ HTTP. Например. `page?par1=HPP_TEST1`
3. Отправить новый запрос, объединяющий шаги (1) и (2). Опять же, сохраните HTTP-ответ. Например. `page?par1=val1&par1=HPP_TEST1`
4. Сравните ответы, полученные на всех предыдущих этапах. Если ответ от (3) отличается от (1), а ответ от (3) также отличается от (2), существует несоответствие импеданса, которое в конечном итоге может быть использовано для запуска уязвимостей HPP.

Создание полного эксплойта из-за слабости параметра загрязнения выходит за рамки этого текста. Смотрите ссылки для примеров и деталей.

### Клиент-сторонняя ГЭС

Как и в случае с HPP на стороне сервера, ручное тестирование является единственным надежным методом аудита веб-приложений с целью выявления уязвимостей загрязнения параметров, влияющих на компоненты на стороне клиента. В то время как в варианте на стороне сервера злоумышленник использует уязвимое веб-приложение для доступа к защищенным данным или для выполнения действий, которые либо не разрешены, либо не должны выполняться, атаки на стороне клиента направлены на подрыв компонентов и технологий на стороне клиента.

Чтобы проверить наличие уязвимостей на стороне клиента HPP, определите любую форму или действие, которое позволяет вводить пользователя и показывает результат этого ввода обратно пользователю. Страница поиска идеальна, но поле входа может не работать (поскольку оно может не отображать неверное имя пользователя обратно пользователю).

Подобно HPP на стороне сервера, загрязняйте каждый параметр HTTP с помощью `%26HPP_TEST` и ищите * url-decoded * вхождения предоставленной пользователем полезной нагрузки:

- `&HPP_TEST`
- `&amp;HPP_TEST`
- etc.

В частности, обратите внимание на ответы, имеющие векторы HPP в `data`, `src`, `href` атрибутах или формах действий. Опять же, независимо от того, показывает ли это поведение по умолчанию потенциальную уязвимость, зависит от конкретной проверки ввода, фильтрации и бизнес-логики приложения. Кроме того, важно отметить, что эта уязвимость также может влиять на параметры строки запроса, используемые в XMLHttpRequest (XHR), создании атрибутов времени выполнения и других технологиях плагинов (например,. Переменные Adobe Flashvars).

## Tools

- [OWASP ZAP Passive/Active Scanners](https://www.zaproxy.org)

## References

### Whitepapers

- [HTTP Parameter Pollution - Luca Carettoni, Stefano di Paola](https://owasp.org/www-pdf-archive/AppsecEU09_CarettoniDiPaola_v0.8.pdf)
- [Client-side HTTP Parameter Pollution Example (Yahoo! Classic Mail flaw) - Stefano di Paola](https://blog.mindedsecurity.com/2009/05/client-side-http-parameter-pollution.html)
- [How to Detect HTTP Parameter Pollution Attacks - Chrysostomos Daniel](https://www.acunetix.com/blog/whitepaper-http-parameter-pollution/)
- [CAPEC-460: HTTP Parameter Pollution (HPP) - Evgeny Lebanidze](https://capec.mitre.org/data/definitions/460.html)
- [Automated Discovery of Parameter Pollution Vulnerabilities in Web Applications - Marco Balduzzi, Carmen Torrano Gimenez, Davide Balzarotti, Engin Kirda](http://s3.eurecom.fr/docs/ndss11_hpp.pdf)
