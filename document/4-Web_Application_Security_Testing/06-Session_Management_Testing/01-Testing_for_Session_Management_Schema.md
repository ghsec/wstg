# Тестирование для схемы управления сессиями

| ID |
| ------------- |
| WSTG-SESS-01 |

## Резюме

Одним из основных компонентов любого веб-приложения является механизм, с помощью которого он контролирует и поддерживает состояние, в котором пользователь взаимодействует с ним. Чтобы избежать непрерывной аутентификации для каждой страницы веб-сайта или службы, веб-приложения реализуют различные механизмы для хранения и проверки учетных данных в течение заранее определенного промежутка времени. Эти механизмы известны как управление сессиями.

В этом тесте тестер хочет проверить, что файлы cookie и другие токены сеанса создаются безопасным и непредсказуемым образом. Злоумышленник, способный предсказать и подделать слабое печенье, может легко перехватить сеансы законных пользователей.

Файлы cookie используются для реализации управления сеансами и подробно описаны в RFC 2965. Короче говоря, когда пользователь получает доступ к приложению, которое должно отслеживать действия и личность этого пользователя по нескольким запросам, файл cookie (или файлы cookie) генерируется сервером и отправляется клиенту. Затем клиент отправит cookie-файл обратно на сервер во всех следующих соединениях, пока cookie не истечет или не будет уничтожен. Данные, хранящиеся в файле cookie, могут предоставить серверу широкий спектр информации о том, кто является пользователем, какие действия он выполнил до сих пор, каковы его предпочтения и т. Д. поэтому предоставление состояния протоколу без гражданства, как HTTP .

Типичный пример - онлайн-корзина. На протяжении всего сеанса пользователя приложение должно отслеживать его личность, его профиль, продукты, которые он выбрал для покупки, количество, индивидуальные цены, скидки и т. Д. Файлы cookie - это эффективный способ хранения и передачи этой информации туда и обратно (другие методы - это параметры URL и скрытые поля).

Ввиду важности данных, которые они хранят, файлы cookie имеют жизненно важное значение для общей безопасности приложения. Возможность подделывать файлы cookie может привести к перехвату сеансов законных пользователей, получению более высоких привилегий в активном сеансе и в целом к несанкционированному влиянию на работу приложения.

В этом тесте тестер должен проверить, могут ли файлы cookie, выпущенные для клиентов, противостоять широкому кругу атак, направленных на вмешательство в сеансы законных пользователей и в само приложение. Общая цель состоит в том, чтобы иметь возможность подделать cookie, который будет считаться действительным в приложении и который обеспечит какой-либо несанкционированный доступ (угон сеанса, повышение привилегий) ...).

Обычно основными шагами шаблона атаки являются следующие:

- **cookie collection**: сбор достаточного количества образцов печенья;
- **cookie reverse engineering**: анализ алгоритма генерации файлов cookie;
- **cookie manipulation**: ковка действительного печенья для выполнения атаки. Этот последний шаг может потребовать большого количества попыток, в зависимости от того, как создается cookie (атака методом cookie-силы).

Другая модель атаки состоит из переполнения печенья. Строго говоря, эта атака имеет другую природу, поскольку здесь тестировщики не пытаются воссоздать совершенно действительный файл cookie. Вместо этого цель состоит в том, чтобы переполнить область памяти, тем самым мешая правильному поведению приложения и, возможно, вводя (и удаленно выполняя) вредоносный код.

## Цели теста

- Собирайте токены сеанса для одного и того же пользователя и для разных пользователей, где это возможно.
- Анализируйте и убедитесь, что существует достаточно случайности, чтобы остановить сеансовые атаки.
- Изменить файлы cookie, которые не подписаны, и содержать информацию, которой можно манипулировать.

## Как проверить

### Тестирование и примеры Black-Box

Все взаимодействие между клиентом и приложением должно быть проверено, по крайней мере, по следующим критериям:

- Все ли директивы `Set-Cookie` помечены как `Secure`?
- Выполняют ли какие-либо операции с Cookie по незашифрованной транспортировке?
- Можно ли принудительно переправить печенье на незашифрованный транспорт??
- Если да, то как приложение поддерживает безопасность?
- Любые файлы cookie постоянны?
- Какие «расширения» используются на постоянных файлах cookie, и являются ли они разумными?
- Являются ли файлы cookie, которые, как ожидается, будут настроены как таковые?
- Какие настройки HTTP / 1.1 `Cache-Control` используются для защиты файлов cookie?
- Какие настройки HTTP / 1.0 `Cache-Control` используются для защиты файлов cookie?

#### Коллекция печенья

Первый шаг, необходимый для манипулирования cookie, - это понять, как приложение создает и управляет файлами cookie. Для этой задачи тестировщики должны попытаться ответить на следующие вопросы:

- Сколько файлов cookie используется приложением?

  Занимайтесь приложением. Обратите внимание, когда создаются куки. Составьте список полученных файлов cookie, страницу, которая их устанавливает (с помощью директивы set-cookie), домен, для которого они действительны, их ценность и их характеристики.

- Какие части приложения генерируют или изменяют cookie?

  Занимаясь серфингом, найдите, какие куки остаются постоянными, а какие модифицируются. Какие события изменяют cookie?

- Какие части приложения требуют этот файл cookie для доступа и использования?

  Узнайте, какие части приложения нуждаются в cookie. Получите доступ к странице, затем попробуйте еще раз без файла cookie или с измененным значением. Попробуйте отобразить, какие куки используются где.

Электронная таблица, отображающая каждый файл cookie для соответствующих частей приложения и соответствующей информации, может быть ценным выходом этого этапа.

#### Анализ сеанса

Сами токены сеанса (Cookie, SessionID или Hidden Field) должны быть проверены, чтобы обеспечить их качество с точки зрения безопасности. Они должны быть проверены на соответствие таким критериям, как их случайность, уникальность, устойчивость к статистическому и криптографическому анализу и утечка информации.

- Структура токенов и утечка информации

Первым этапом является изучение структуры и содержания идентификатора сеанса, предоставленного приложением. Распространенной ошибкой является включение определенных данных в токен вместо выдачи общего значения и ссылки на реальный сервер данных.

Если идентификатор сеанса имеет четкий текст, структура и соответствующие данные могут быть сразу очевидны, такие как `192.168.100.1: owaspuser: пароль: 15: 58`.

Если часть или весь токен, по-видимому, закодированы или хешированы, его следует сравнить с различными методами проверки на очевидную запутывание. Например, строка `192.168.100.1: owaspuser: password: 15: 58` представлена в Hex, Base64 и в виде хеша MD5 :

- Hex: `3139322E3136382E3130302E313A6F77617370757365723A70617373776F72643A31353A3538`
- Base64: `MTkyLjE2OC4xMDAuMTpvd2FzcHVzZXI6cGFzc3dvcmQ6MTU6NTg=`
- MD5: `01c2fc4f0a817afd8366689bd29dd40a`

Определив тип запутывания, можно будет расшифровать исходные данные. Однако в большинстве случаев это маловероятно. Тем не менее, может быть полезно перечислить кодировку на месте из формата сообщения. Кроме того, если можно вывести как формат, так и технику запутывания, можно разработать автоматические атаки грубой силы.

Гибридные токены могут включать информацию, такую как IP-адрес или идентификатор пользователя, вместе с кодированной частью, такой как `owaspuser: 192.168.100.1: a7656fafe94dae72b1e1487670148412`.

Проанализировав один токен сеанса, следует изучить репрезентативную выборку. Простой анализ токенов должен немедленно выявить любые очевидные закономерности. Например, 32-битный токен может включать 16 битов статических данных и 16 битов переменных данных. Это может указывать на то, что первые 16 бит представляют фиксированный атрибут пользователя - например,. имя пользователя или IP-адрес. Если второй 16-битный кусок увеличивается с регулярной скоростью, он может указывать на последовательный или даже основанный на времени элемент для генерации токена. Смотрите примеры.

Если статические элементы токенов идентифицированы, следует собрать дополнительные образцы, изменяя один потенциальный входной элемент за раз. Например, попытки входа в систему через другую учетную запись пользователя или с другого IP-адреса могут привести к отклонению ранее статической части токена сеанса.

Следующие области должны быть рассмотрены во время тестирования структуры идентификатора сеанса и нескольких сеансов:

- Какие части идентификатора сеанса являются статическими?
- Какая конфиденциальная информация в виде открытого текста хранится в идентификаторе сеанса? Например. имена пользователей / UID, IP-адреса
- Какая легко декодированная конфиденциальная информация сохраняется?
- Какую информацию можно вывести из структуры идентификатора сеанса?
- Какие части идентификатора сеанса являются статическими для одного и того же режима входа в систему?
- Какие очевидные закономерности присутствуют в идентификаторе сеанса в целом или отдельных частях?

#### ID сеанса Предсказуемость и случайность

Анализ переменных областей (если таковые имеются) идентификатора сеанса должен проводиться для установления существования любых узнаваемых или предсказуемых моделей. Эти анализы могут выполняться вручную и с помощью специальных статистических или криптоаналитических инструментов OTS для определения любых шаблонов в содержимом идентификатора сеанса. Ручные проверки должны включать сравнение идентификаторов сессий, выданных для тех же условий входа - например,., то же имя пользователя, пароль и IP-адрес.

Время является важным фактором, который также необходимо контролировать. Большое количество одновременных соединений должно быть сделано для того, чтобы собирать образцы в одном временном окне и поддерживать эту переменную постоянной. Даже квантование в 50 мс или менее может быть слишком грубым, и выборка, взятая таким образом, может выявить компоненты, основанные на времени, которые в противном случае были бы пропущены.

Переменные элементы должны быть проанализированы с течением времени, чтобы определить, являются ли они постепенными по своему характеру. Там, где они являются инкрементными, следует исследовать закономерности, относящиеся к абсолютному или истекшему времени. Многие системы используют время как семя для своих псевдослучайных элементов. Там, где закономерности кажутся случайными, односторонние таймы времени или другие изменения окружающей среды следует рассматривать как возможность. Как правило, результат криптографического хеша является десятичным или шестнадцатеричным числом, поэтому его следует идентифицировать.

При анализе последовательностей, шаблонов или циклов идентификатора сеанса все статические элементы и клиентские зависимости должны рассматриваться как возможные способствующие элементы структуры и функции приложения.

- Являются ли идентификаторы сессий доказуемо случайными по своему характеру? Можно ли воспроизвести полученные значения?
- Выполните те же условия ввода, чтобы создать тот же идентификатор в последующем запуске?
- Являются ли идентификаторы сеанса доказуемо устойчивыми к статистическому или криптоанализу?
- Какие элементы идентификаторов сессий связаны во времени?
- Какие части идентификаторов сессий предсказуемы?
- Можно ли вывести следующий идентификатор, учитывая полное знание алгоритма генерации и предыдущих идентификаторов?

#### Cookie Reverse Engineering

Теперь, когда тестер перечислил куки и имеет общее представление об их использовании, пришло время глубже взглянуть на куки, которые кажутся интересными. Какие куки интересуют тестер? Файл cookie, чтобы обеспечить безопасный метод управления сеансом, должен сочетать несколько характеристик, каждая из которых направлена на защиту файла cookie от другого класса атак.

Эти характеристики приведены ниже:

1. Непредсказуемость: cookie должен содержать некоторое количество трудно угадываемых данных. Чем сложнее создать действительный файл cookie, тем сложнее взломать сеанс законного пользователя. Если злоумышленник может угадать cookie, используемый в активном сеансе законного пользователя, он сможет полностью выдать себя за этого пользователя (захват сеанса). Чтобы сделать cookie непредсказуемым, можно использовать случайные значения или криптографию.
2. Сопротивление несанкционированному вмешательству: cookie должен противостоять злонамеренным попыткам модификации. Если тестер получает cookie, такой как «IsAdmin = No», тривиально изменить его, чтобы получить административные права, если только приложение не выполняет двойную проверку (например, добавляя к cookie зашифрованный хэш его значения)
3. Срок действия: критический файл cookie должен быть действителен только в течение соответствующего периода времени и впоследствии должен быть удален с диска или памяти, чтобы избежать риска его воспроизведения. Это не относится к файлам cookie, которые хранят некритические данные, которые необходимо запоминать на разных сессиях (например,., внешний вид сайта).
4. Флаг «Безопасный»: cookie-файл, значение которого имеет решающее значение для целостности сеанса, должен включать этот флаг, чтобы его передача могла осуществляться только в зашифрованном канале для предотвращения прослушивания.

Подход здесь состоит в том, чтобы собрать достаточное количество экземпляров файла cookie и начать поиск шаблонов по их стоимости. Точное значение «достаточный» может варьироваться от нескольких образцов, если метод генерации файлов cookie очень легко сломать, до нескольких тысяч, если тестер должен приступить к некоторому математическому анализу (например,.хи-квадраты, аттракторы. Смотрите позже для получения дополнительной информации).

Важно уделять особое внимание рабочему процессу приложения, поскольку состояние сеанса может оказать сильное влияние на собранные файлы cookie. Файл cookie, собранный до аутентификации, может сильно отличаться от файла cookie, полученного после аутентификации.

Еще один аспект, который следует учитывать, это время. Всегда записывайте точное время получения файла cookie, когда существует вероятность того, что время играет роль в значении файла cookie (сервер может использовать метку времени как часть значения файла cookie). Записанным временем может быть локальное время или метка сервера, включенная в ответ HTTP (или оба).

При анализе собранных значений тестер должен попытаться выяснить все переменные, которые могли повлиять на значение cookie, и попытаться изменить их по одному. Передача на сервер модифицированных версий одного и того же файла cookie может быть очень полезна для понимания того, как приложение читает и обрабатывает файл cookie.

Примеры проверок, которые должны быть выполнены на этом этапе, включают:

- Какой набор символов используется в файле cookie? Имеет cookie числовое значение? буквенно-цифровой? шестнадцатеричный? Что произойдет, если тестер вставит символы cookie, которые не принадлежат ожидаемой кодировке?
- Является ли cookie-файл составной из разных частей, несущих разные фрагменты информации? Как разные части разделены? С какими разделителями? Некоторые части cookie могут иметь более высокую дисперсию, другие могут быть постоянными, другие могут принимать только ограниченный набор значений. Разбивка печенья на его базовые компоненты является первым и фундаментальным шагом.

Примером легко обнаруживаемого структурированного файла cookie является следующее:

```text
ID=5a0acfc7ffeb919:CR=1:TM=1120514521:LM=1120514521:S=j3am5KzC4v01ba3q
```

В топоме проказы 5 различных полей, неотличий разных данных

- ID - шестнадцатеричный
- CR - маленькое целое число
- ТМ и ЛМ - большое целое число. (И, как ни странно, они имеют одинаковую ценность. Стоит посмотреть, что происходит с изменением одного из них)
- S - буквенно-цифровой

Даже когда разделители не используются, наличие достаточного количества образцов может помочь понять структуру.

#### Атаки грубой силы

Атаки грубой силы неизбежно ведут к вопросам, касающимся предсказуемости и случайности. Разница в идентификаторах сеанса должна рассматриваться вместе с продолжительностью сеанса приложения и тайм-аутами. Если изменение идентификаторов сеанса относительно невелико, а действительность идентификатора сеанса велика, вероятность успешной атаки методом грубой силы намного выше.

Длинный идентификатор сеанса (или, скорее, с большой дисперсией) и более короткий срок действия значительно затруднят успех в атаке грубой силы.

- Сколько времени займет атака грубой силы на все возможные идентификаторы сеанса?
- Достаточно ли велико пространство идентификатора сеанса, чтобы предотвратить грубое воздействие? Например, длина ключа достаточна по сравнению с допустимым сроком службы?
- Задержки между попытками подключения с различными идентификаторами сеанса снижают риск этой атаки?

### Тестирование и пример серой коробки

Если тестер имеет доступ к реализации схемы управления сеансом, он может проверить следующее:

- Случайный токен сеанса

  Идентификатор сеанса или cookie, выданные клиенту, не должны быть легко предсказуемыми (не используйте линейные алгоритмы, основанные на предсказуемых переменных, таких как IP-адрес клиента). Рекомендуется использовать криптографические алгоритмы с длиной ключа 256 бит (например, AES).

- Длина жетона

  Идентификатор сеанса будет длиной не менее 50 символов.

- Тайм-аут сессии

  Токен сеанса должен иметь определенный тайм-аут (это зависит от критичности данных, управляемых приложением)

- Конфигурация файлов cookie:
    - non-persistent: только оперативная память
    - secure (устанавливается только на канале HTTPS) : `Set-Cookie: cookie=data; path=/; domain=.aaa.it; secure`
    - [HTTPOnly](https://owasp.org/www-community/HttpOnly) (не читается сценарием): `Set-Cookie: cookie=data; path=/; domain=.aaa.it; HttpOnly`

Больше информации здесь: [Testing for cookies attributes](02-Testing_for_Cookies_Attributes.md)

## Tools

- [OWASP Zed Attack Proxy Project (ZAP)](https://www.zaproxy.org) - features a session token analysis mechanism.
- [Burp Sequencer](https://portswigger.net/burp/documentation/desktop/tools/sequencer)
- [YEHG's JHijack](https://github.com/yehgdotnet/JHijack)

## References

### Whitepapers

- [RFC 2965 "HTTP State Management Mechanism"](https://tools.ietf.org/html/rfc2965)
- [RFC 1750 "Randomness Recommendations for Security"](https://www.ietf.org/rfc/rfc1750.txt)
- [Michal Zalewski: "Strange Attractors and TCP/IP Sequence Number Analysis" (2001)](http://lcamtuf.coredump.cx/oldtcp/tcpseq.html)
- [Michal Zalewski: "Strange Attractors and TCP/IP Sequence Number Analysis - One Year Later" (2002)](http://lcamtuf.coredump.cx/newtcp/)
- [Correlation Coefficient](http://mathworld.wolfram.com/CorrelationCoefficient.html)
- [ENT](https://fourmilab.ch/random/)
- [DMA[2005-0614a] - 'Global Hauri ViRobot Server cookie overflow'](https://seclists.org/lists/fulldisclosure/2005/Jun/0188.html)
- [Gunter Ollmann: "Web Based Session Management"](http://www.technicalinfo.net)
- [OWASP Code Review Guide](https://wiki.owasp.org/index.php/Category:OWASP_Code_Review_Project)
