# Тестирование веб-токенов JSON

| ID |
| ------------- |
| WSTG-SESS-10 |

## Резюме

Веб-токены JSON (JWT) представляют собой криптографически подписанные токены JSON, предназначенные для обмена претензиями между системами. Они часто используются в качестве аутентификации или токенов сеанса, особенно в API REST.

JWT являются распространенным источником уязвимостей как в том, как они применяются в приложениях, так и в базовых библиотеках. Поскольку они используются для аутентификации, уязвимость может легко привести к полному компромиссу приложения.

## Цели теста

- Определите, предоставляют ли JWT конфиденциальную информацию.
- Определите, могут ли JWT быть подделаны или изменены.

## Как проверить

### Обзор

JWT состоят из трех компонентов:

- Заголовок
- Полезная нагрузка (или тело)
- Подпись

Каждый компонент имеет кодировку Base64, и они разделены периодами (`.`). Обратите внимание, что кодировка Base64, используемая в JWT, удаляет знаки равенства (`= `), поэтому вам может потребоваться добавить их обратно для декодирования разделов.

### Проанализируйте содержание

#### Заголовок

Заголовок определяет тип токена (обычно `JWT`) и алгоритм, используемый для подписи. Пример декодированного заголовка показан ниже:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
Существует три основных типа алгоритмов, которые используются для расчета подписей:

| Algorithm | Description |
|-----------|-------------|
| HSxxx | HMAC using a secret key and SHA-xxx. |
| RSxxx and PSxxx | Public key signature using RSA. |
| ESxxx | Public key signature using ECDSA. |

Есть также широкий спектр [other algorithms](https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms) которые могут использоваться для зашифрованных токенов (JWE), хотя они встречаются реже.

#### Полезная нагрузка

Полезная нагрузка JWT содержит фактические данные. Пример полезной нагрузки показан ниже:

```json
{
  "username": "admininistrator",
  "is_admin": true,
  "iat": 1516239022,
  "exp": 1516242622
}
```

Полезная нагрузка обычно не зашифрована, поэтому просмотрите ее, чтобы определить, есть ли в ней какие-либо конфиденциальные данные, потенциально неподходящие.

Этот JWT включает имя пользователя и административный статус пользователя, а также две стандартные претензии (`iat` и `exp`). Эти претензии определены в [RFC 5719](https://tools.ietf.org/html/rfc7519#section-4.1),  краткое их резюме приведено в таблице ниже:

| Claim | Full Name | Description |
|-------|-----------|-------------|
| `iss` | Issuer | The identity of the party who issued the token. |
| `iat` | Issued At | The Unix timestamp of when the token was issued. |
| `nbf` | Not Before | The Unix timestamp of earliest date that the token can be used. |
| `exp` | Expires | The Unix timestamp of when the token expires. |

#### Подпись

Подпись рассчитывается с использованием алгоритма, определенного в заголовке JWT, а затем Base64 кодируется и добавляется к токену. Изменение любой части JWT должно привести к тому, что подпись будет недействительной, а токен будет отклонен сервером.

### Обзор использования

Помимо криптографической безопасности, JWT также необходимо хранить и отправлять безопасным способом. Это должно включать проверки, которые:

- Это всегда [sent over encrypted (HTTPS) connections](../09-Testing_for_Weak_Cryptography/03-Testing_for_Sensitive_Information_Sent_via_Unencrypted_Channels.md).
- Если он хранится в файле cookie, то так и должно быть [marked with appropriate attributes](../06-Session_Management_Testing/02-Testing_for_Cookies_Attributes.md).

Действительность JWT также должна быть пересмотрена на основе претензий `iat`, `nbf` и `exp`, чтобы определить, что:

- JWT имеет разумный срок службы для приложения.
- Истекшие токены отклоняются приложением.

### Проверка подписи

Одна из наиболее серьезных уязвимостей, с которыми сталкиваются JWT, - это когда приложение не может подтвердить правильность подписи. Обычно это происходит, когда разработчик использует функцию, такую как функция NodeJS `jwt.decode ()`, которая просто декодирует тело JWT, а не `jwt.verify ()`, которая проверяет подпись перед декодированием JWT. ,

Это можно легко проверить, изменив тело JWT, не меняя ничего в заголовке или подписи, отправив его в запросе, чтобы увидеть, принимает ли приложение его.

#### Алгоритм None

Помимо открытого ключа и алгоритмов на основе HMAC, спецификация JWT также определяет алгоритм подписи, называемый `none`. Как следует из названия, это означает, что для JWT нет подписи, позволяющей ее изменять.

Некоторые реализации пытаются избежать этого, явно блокируя использование алгоритма `none`. Если это делается нечувствительным к регистру способом, можно обойти его, указав алгоритм, такой как «NoNe».

Это можно проверить, изменив алгоритм подписи (`alg`) в заголовке JWT на `NoNe`, как показано в примере ниже:

```json
{
        "alg": "NoNe",
        "typ": "JWT"
}
```

Заголовок и полезная нагрузка затем перекодируются с помощью Base64, и подпись удаляется (оставляя период трейлинга). Использование заголовка выше и полезной нагрузки, указанной в [payload](#payload) раздел, это даст следующее JWT:

```txt
eyJhbGciOiAiTm9OZSIsICJ0eXAiOiAiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluaW5pc3RyYXRvciIsImlzX2FkbWluIjp0cnVlLCJpYXQiOjE1MTYyMzkwMjIsImV4cCI6MTUxNjI0MjYyMn0.
```

### Слабые ключи HMAC

Если JWT подписан с использованием алгоритма на основе HMAC (такого как HS256), безопасность подписи полностью зависит от силы секретного ключа, используемого в HMAC

Если приложение использует готовое или открытое программное обеспечение, первым шагом должно быть изучение кода и выяснение того, используется ли ключ подписи HMAC по умолчанию.

Если нет дефолта, то может быть возможно взломать предположение или грубую силу, которую они имеют. Самый простой способ сделать это - использовать [crackjwt.py](https://github.com/Sjord/jwtcrack) скрипт, который просто требует JWT и файл словаря.

Более мощным вариантом является преобразование JWT в формат, который можно использовать [John the Ripper](https://github.com/openwall/john) используя [jwt2john.py](https://github.com/Sjord/jwtcrack/blob/master/jwt2john.py) скрипт. Затем Джона можно использовать для более совершенных атак на ключ.

Если JWT большой, он может превышать максимальный размер, поддерживаемый Джоном. Это можно обойти, увеличив значение переменной `SALT_LIMBS` в `/src/hmacSHA256_fmt_plug.c` (или эквивалентный файл для других форматов HMAC) и перекомпиляция Джона, как описано ниже [GitHub issue](https://github.com/openwall/john/issues/1904).

Если этот ключ можно получить, то можно создать и подписать произвольные JWT, что обычно приводит к полному компромиссу приложения.

### HMAC против путаницы в открытых ключах

Если приложение использует JWT с сигнатурами на основе открытых ключей, но не проверяет правильность алгоритма, это может потенциально использовать его в атаке путаницы типа подписи. Чтобы это было успешным, необходимо выполнить следующие условия:

1. Приложение должно ожидать, что JWT будет подписан с алгоритмом на основе открытого ключа (т. Е. `RSxxx` или `ESxxx`).
2. Приложение не должно проверять, какой алгоритм JWT фактически использует для подписи.
3. Открытый ключ, используемый для проверки JWT, должен быть доступен злоумышленнику.

Если все эти условия верны, злоумышленник может использовать открытый ключ для подписи JWT с использованием алгоритма на основе HMAC (например, `HS256`). Например, [Node.JS jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken) библиотека использует одну и ту же функцию как для открытого ключа, так и для токенов на основе HMAC, как показано в примере ниже:

```javascript
// Verify a JWT signed using RS256
jwt.verify(token, publicKey);

// Verify a JWT signed using HS256
jwt.verify(token, secretKey);
```

Это означает, что если JWT подписан с использованием `publicKey` в качестве секретного ключа для алгоритма `HS256`, подпись будет считаться действительной.

Чтобы использовать эту проблему, необходимо получить открытый ключ. Наиболее распространенный способ, которым это может произойти, - это если приложение повторно использует один и тот же ключ как для подписи JWT, так и в качестве части сертификата TLS. В этом случае ключ можно загрузить с сервера с помощью команды, такой как:

```sh
openssl s_client -connect example.org:443 | openssl x509 -pubkey -noout
```

В качестве альтернативы ключ может быть доступен из общедоступного файла на сайте в общем месте, например `/.well-known/jwks.json`.

Чтобы проверить это, измените содержимое JWT, а затем используйте ранее полученный открытый ключ, чтобы подписать JWT с использованием алгоритма `HS256`. Это часто бывает трудно выполнить при тестировании без доступа к исходному коду или деталям реализации, потому что формат ключа должен быть идентичен тому, который используется сервером, поэтому такие проблемы, как пустое пространство или кодирование CRLF, могут привести к тому, что ключи не будут совпадать.

### Атакующий предоставил открытый ключ

The [JSON Web Signature (JWS) standard](https://tools.ietf.org/html/rfc7515) (который определяет заголовок и подписи, используемые JWT) позволяет клавише, используемой для подписи токена, быть встроенным в заголовок. Если библиотека, используемая для проверки токена, поддерживает это и не проверяет ключ по списку утвержденных ключей, это позволяет злоумышленнику подписать JWT с произвольным ключом, который они предоставляют.

Для этого можно использовать различные сценарии, например [jwk-node-jose.py](https://github.com/zi0Black/POC-CVE-2018-0114) or [jwt_tool](https://github.com/ticarpi/jwt_tool).

## Related Test Cases

- [Testing for Sensitive Information Sent via Unencrypted Channels](../09-Testing_for_Weak_Cryptography/03-Testing_for_Sensitive_Information_Sent_via_Unencrypted_Channels.md).
- [Testing for Cookie Attributes](../06-Session_Management_Testing/02-Testing_for_Cookies_Attributes.md).
- [Testing Browser Storage](../11-Client-side_Testing/12-Testing_Browser_Storage.md).

## Восстановление

- Используйте безопасную и актуальную библиотеку для обработки JWT.
- Убедитесь, что подпись действительна и что она использует ожидаемый алгоритм.
- Используйте сильный ключ HMAC или уникальный закрытый ключ, чтобы подписать их.
- Убедитесь, что в полезной нагрузке не обнаружена конфиденциальная информация.
- Убедитесь, что JWT надежно хранятся и передаются.
- Смотрите [OWASP JSON Web Tokens Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html).

## Tools

- [John the Ripper](https://github.com/openwall/john)
- [jwt2john](https://github.com/Sjord/jwtcrack)
- [jwt-cracker](https://github.com/brendan-rius/c-jwt-cracker)
- [JSON Web Tokens Burp Extension](https://portswigger.net/bappstore/f923cbf91698420890354c1d8958fee6)
- [ZAP JWT Add-on](https://github.com/SasanLabs/owasp-zap-jwt-addon)

## References

- [RFC 7515 JSON Web Signature (JWS)](https://tools.ietf.org/html/rfc7515)
- [RFC 7519 JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519)
- [OWASP JSON Web Token Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
