# Тестирование на подделку межсайтовых запросов

| ID |
| ------------- |
| WSTG-SESS-05 |

## Резюме

Кросс-сайт Запрос подделки ([CSRF](https://owasp.org/www-community/attacks/csrf)) это атака, которая заставляет конечного пользователя выполнять непреднамеренные действия в веб-приложении, в котором они в настоящее время аутентифицированы. С небольшой помощью социальной инженерии (например, отправка ссылки по электронной почте или в чате) злоумышленник может заставить пользователей веб-приложения выполнить действия по выбору злоумышленника. Успешный эксплойт CSRF может поставить под угрозу данные и работу конечного пользователя, когда он нацелен на нормального пользователя. Если целевой конечный пользователь является учетной записью администратора, атака CSRF может поставить под угрозу все веб-приложение.

CSRF полагается на:

1. Поведение веб-браузера в отношении обработки информации, связанной с сеансом, такой как файлы cookie и информация аутентификации HTTP.
2. Знаяние злоумышленником действительных URL-адресов, запросов или функций веб-приложений.
3. Управление сеансом приложения, опираясь только на информацию, известную браузером.
4. Наличие тегов HTML, присутствие которых вызывает немедленный доступ к ресурсу HTTP [S]; например, тег изображения `img`.

Пункты 1, 2 и 3 необходимы для присутствия уязвимости, в то время как пункт 4 облегчает фактическую эксплуатацию, но не является строго обязательным.

1. Браузеры автоматически отправляют информацию, используемую для идентификации пользовательского сеанса. Предположим, что * site * - это сайт, на котором размещено веб-приложение, а пользователь * victim * только что прошел аутентификацию на * site *. В ответ * site * отправляет * victim * cookie-файл, который идентифицирует запросы, отправленные * victim * как принадлежащие к аутентифицированному сеансу * victim *. Как только браузер получит cookie-файл, установленный * site *, он автоматически отправит его вместе с любыми дополнительными запросами, направленными на * site *.
2. Если приложение не использует информацию, связанную с сеансом, в URL-адресах, то могут быть определены URL-адреса приложений, их параметры и законные значения. Это может быть достигнуто путем анализа кода или путем доступа к приложению и принятия к сведению форм и URL-адресов, встроенных в HTML или JavaScript.
3. «Известный браузером» относится к такой информации, как файлы cookie или информация аутентификации на основе HTTP (например, базовая аутентификация, а не аутентификация на основе форм), которые хранятся браузером и впоследствии присутствуют при каждом запросе, направленном в область приложения, запрашивающую это. аутентификация. Обсуждаемые ниже уязвимости применяются к приложениям, которые полностью используют такую информацию для идентификации сеанса пользователя.

Для простоты рассмотрите доступные для GET URL-адреса (хотя обсуждение относится и к запросам POST). Если * victim * уже аутентифицировался, отправка другого запроса приводит к автоматической отправке файла cookie вместе с ним. На рисунке ниже показан пользователь, имеющий доступ к приложению `www.example.com`.

![Session Riding](images/Session_riding.GIF)\
*Figure 4.6.5-1: Session Riding*

Запрос GET может быть отправлен пользователем несколькими различными способами:

- Использование веб-приложения
- Напечатывание URL прямо в браузере
- По внешней ссылке, которая указывает на URL

Эти вызовы неразличимы приложением. В частности, третий может быть довольно опасным. Существует ряд методов и уязвимостей, которые могут маскировать реальные свойства ссылки. Ссылка может быть встроена в сообщение электронной почты, отображаться на вредоносном веб-сайте, на который заманивается пользователь, или отображаться в контенте, размещенном третьей стороной (например, на другом веб-сайте или в электронной почте HTML), и указывать на ресурс приложения. ,. Если пользователь нажимает на ссылку, поскольку они уже аутентифицированы веб-приложением на * сайте *, браузер выдает запрос GET в веб-приложение, сопровождаемый информацией аутентификации (файл cookie идентификатора сеанса). Это приводит к тому, что в веб-приложении выполняется действительная операция, которую пользователь не ожидает; например, перевод средств в приложение веб-банкинга.

Используя тег, такой как `img`, как указано в пункте 4 выше, даже не обязательно, чтобы пользователь следовал по определенной ссылке. Предположим, что злоумышленник отправляет пользователю электронное письмо, побуждающее его посетить URL-адрес, ссылающийся на страницу, содержащую следующий (неусиленный) HTML-код

```html
<html>
    <body>
...
<img src="https://www.company.example/action" width="0" height="0">
...
    </body>
</html>
```

Когда браузер отображает эту страницу, он попытается отобразить указанное изображение нулевого размера (таким образом, невидимое) `https://www.company.example` также. Это приводит к тому, что запрос автоматически отправляется в веб-приложение, размещенное на * сайте *. Не важно, чтобы URL-адрес изображения не ссылался на правильное изображение, поскольку его присутствие в любом случае вызовет запрос `action`, указанный в поле `src`. Это происходит при условии, что загрузка изображения не отключена в браузере. В большинстве браузеров загрузка изображений не отключена, поскольку это может нанести ущерб большинству веб-приложений, выходящих за рамки удобства использования.

Проблема здесь является следствием:

- HTML-теги на странице, приводящие к автоматическому выполнению HTTP-запроса («img» является одним из них).
- Браузер не может сказать, что ресурс, на который ссылается `img`, не является законным изображением.
- Загрузка изображения, которая происходит независимо от местоположения предполагаемого источника изображения, т.е.форма и само изображение не должны находиться на одном хосте или даже в одном домене.

Тот факт, что HTML-контент, не связанный с веб-приложением, может относиться к компонентам в приложении, и тот факт, что браузер автоматически создает действительный запрос к приложению, допускает такого рода атаки. Невозможно запретить такое поведение, если злоумышленнику не будет невозможно взаимодействовать с функциональностью приложения.

В интегрированных средах почты / браузера простое отображение сообщения электронной почты, содержащего ссылку на изображение, приведет к выполнению запроса к веб-приложению с помощью соответствующего файла cookie браузера. Сообщения электронной почты могут ссылаться на, казалось бы, действительные URL-адреса изображений, такие как:

```html
<img src="https://[attacker]/picture.gif" width="0" height="0">
```

В этом примере `[атакующий] `- это сайт, контролируемый злоумышленником. Используя механизм перенаправления, вредоносный сайт может использовать `http://[attacker]/picture.gif` to направить жертву к `http://[thirdparty]/action` и запустить `action`.

Файлы cookie - не единственный пример, связанный с такой уязвимостью. Веб-приложения, информация о сеансе которых полностью предоставляется браузером, также уязвимы. Это включает приложения, использующие только механизмы аутентификации HTTP, поскольку информация аутентификации известна браузеру и отправляется автоматически по каждому запросу. Это не включает аутентификацию на основе форм, которая происходит только один раз и генерирует некоторую форму информации, связанной с сеансом, обычно cookie.

Предположим, что жертва вошла в консоль управления брандмауэром. Чтобы войти, пользователь должен аутентифицировать себя, а информация о сеансе хранится в файле cookie.

Предположим, что консоль веб-управления брандмауэра имеет функцию, которая позволяет аутентифицированному пользователю удалять правило, указанное в его числовом идентификаторе, или все правила в конфигурации, если пользователь указывает `*` (опасная особенность в реальности, но тот, который делает для более интересного примера). Страница удаления отображается следующим образом. Предположим, что форма - для простоты - выдает запрос GET. Чтобы удалить правило номер один:

```text
https://[target]/fwmgt/delete?rule=1
```

Чтобы удалить все правила:

```text
https://[target]/fwmgt/delete?rule=*
```

Этот пример намеренно наивен, но в упрощенном виде показывает опасность CSRF

![Session Riding Firewall Management](images/Session_Riding_Firewall_Management.gif)\
*Figure 4.6.5-2: Session Riding Firewall Management*

Используя форму, изображенную на рисунке выше, введя значение `*` и нажав кнопку Удалить, вы отправите следующий запрос GET:

```text
https://www.company.example/fwmgt/delete?rule=*
```

Это удалит все правила брандмауэра.

![Session Riding Firewall Management 2](images/Session_Riding_Firewall_Management_2.gif)\
*Figure 4.6.5-3: Session Riding Firewall Management 2*

Пользователь также мог достичь тех же результатов, отправив URL-адрес вручную

```text
https://[target]/fwmgt/delete?rule=*
```

Или перейдя по ссылке, направленной напрямую или через перенаправление на указанный выше URL. Или, опять же, путем доступа к HTML-странице со встроенным тегом `img`, указывающим на тот же URL

Во всех этих случаях, если пользователь в данный момент вошел в приложение управления брандмауэром, запрос будет успешным и изменит конфигурацию брандмауэра. Можно представить атаки на чувствительные приложения и автоматические аукционные предложения, денежные переводы, заказы, изменение конфигурации критически важных программных компонентов и т. Д.

Интересно, что эти уязвимости могут быть реализованы за брандмауэром; то есть. достаточно, чтобы атакованная связь была доступна жертве, а не непосредственно злоумышленнику. В частности, это может быть любой веб-сервер интрасети; например, в сценарии управления брандмауэром, упомянутом ранее, который вряд ли будет открыт для Интернета.

Самоуязвимые приложения, т.е. приложения, которые используются как вектор атаки, так и цель (например, приложения веб-почты), ухудшают ситуацию. Поскольку пользователи входят в систему при чтении своих сообщений электронной почты, уязвимое приложение этого типа может позволить злоумышленникам выполнять такие действия, как удаление сообщений или отправка сообщений, которые, по-видимому, происходят от жертвы.

## Цели теста

- Определите, возможно ли инициировать запросы от имени пользователя, которые не инициированы пользователем.

## Как проверить

Аудит приложения, чтобы выяснить, уязвимо ли его управление сессиями. Если управление сеансом зависит только от значений на стороне клиента (информация доступна для браузера), то приложение уязвимо. «Значения на стороне клиента» относятся к файлам cookie и учетным данным аутентификации HTTP (базовая аутентификация и другие формы аутентификации HTTP; не аутентификация на основе форм, которая является аутентификацией на уровне приложения).

Ресурсы, доступные через HTTP-запросы GET, легко уязвимы, хотя запросы POST могут быть автоматизированы через JavaScript и также уязвимы; следовательно, одного использования POST недостаточно для исправления появления уязвимостей CSRF.

В случае POST можно использовать следующий образец.

1. Создайте HTML-страницу, аналогичную показанной ниже
2. Размещайте HTML на вредоносном или стороннем сайте
3. Отправьте ссылку на страницу жертве (жертвам) и заставьте их щелкнуть по ней.

```html
<html>
<body onload='document.CSRF.submit()'>

<form action='http://targetWebsite/Authenticate.jsp' method='POST' name='CSRF'>
    <input type='hidden' name='name' value='Hacked'>
    <input type='hidden' name='password' value='Hacked'>
</form>

</body>
</html>
```

В случае веб-приложений, в которых разработчики используют JSON для связи между браузером и сервером, может возникнуть проблема с тем фактом, что нет параметров запроса с форматом JSON, которые являются обязательными для самостоятельной отправки форм. Чтобы обойти этот случай, мы можем использовать самоподдающуюся форму с полезными нагрузками JSON, включая скрытый вход, для использования CSRF. Нам придется изменить тип кодирования (`enctype`) на `text / plain`, чтобы гарантировать, что полезная нагрузка доставляется как есть. Код эксплойта будет выглядеть следующим образом:

```html
<html>
 <body>
  <script>history.pushState('', '', '/')</script>
   <form action='http://victimsite.com' method='POST' enctype='text/plain'>
     <input type='hidden' name='{"name":"hacked","password":"hacked","padding":"'value='something"}' />
     <input type='submit' value='Submit request' />
   </form>
 </body>
</html>
```

Запрос POST будет следующим:

```http
POST / HTTP/1.1
Host: victimsite.com
Content-Type: text/plain

{"name":"hacked","password":"hacked","padding":"=something"}
```

Когда эти данные отправляются в качестве запроса POST, сервер с радостью примет поля имени и пароля и проигнорирует поле с набивкой имени, поскольку оно ему не нужно.

## Восстановление

- Смотрите [OWASP CSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) для профилактических мероприятий.

## Tools

- [OWASP ZAP](https://www.zaproxy.org/)
- [CSRF Tester](https://wiki.owasp.org/index.php/Category:OWASP_CSRFTester_Project)
- [Pinata-csrf-tool](https://code.google.com/archive/p/pinata-csrf-tool/)

## References

- [Peter W: "Cross-Site Request Forgeries"](https://web.archive.org/web/20160303230910/http://www.tux.org/~peterw/csrf.txt)
- [Thomas Schreiber: "Session Riding"](https://web.archive.org/web/20160304001446/http://www.securenet.de/papers/Session_Riding.pdf)
- [Oldest known post](https://web.archive.org/web/20000622042229/http://www.zope.org/Members/jim/ZopeSecurity/ClientSideTrojan)
- [Cross-site Request Forgery FAQ](https://www.cgisecurity.com/csrf-faq.html)
- [A Most-Neglected Fact About Cross Site Request Forgery (CSRF)](http://yehg.net/lab/pr0js/view.php/A_Most-Neglected_Fact_About_CSRF.pdf)
- [Multi-POST CSRF](https://www.lanmaster53.com/2013/07/17/multi-post-csrf/)
- [SANS Pen Test Webcast: Complete Application pwnage via Multi POST XSRF](https://www.youtube.com/watch?v=EOs5PZiiwug)
