# Тестирование для открытых переменных сеанса

| ID |
| ------------- |
| WSTG-SESS-04 |

## Резюме

Знаки сеанса (Cookie, SessionID, Hidden Field), если они выставлены, обычно позволяют злоумышленнику выдать себя за жертву и получить доступ к приложению незаконно. Важно, чтобы они всегда были защищены от прослушивания, особенно при транспортировке между клиентским браузером и серверами приложений.

Информация здесь относится к тому, как транспортная безопасность применяется к передаче конфиденциальных данных Session ID, а не данных в целом, и может быть более строгой, чем политика кэширования и транспортировки, применяемая к данным, обслуживаемым сайтом.

Используя персональный прокси, можно узнать следующее о каждом запросе и ответе:

- используемый протокол (например,., HTTP против. HTTPS)
- HTTP-заголовки
- Тело сообщения (например,., POST или содержание страницы)

Каждый раз, когда данные идентификатора сеанса передаются между клиентом и сервером, необходимо изучить протокол, кэш и директивы и тело конфиденциальности. Транспортная безопасность здесь относится к идентификаторам сеансов, передаваемым в запросах GET или POST, телах сообщений или других средствах по действительным HTTP-запросам.

## Цели теста

- Убедитесь, что реализовано правильное шифрование.
- Просмотр конфигурации кэширования.
- Оцените безопасность канала и методов.

## Как проверить

### Тестирование на шифрование и повторное использование уязвимостей токенов сеанса

Защита от прослушивания часто обеспечивается шифрованием SSL, но может включать в себя другие туннели или шифрование. Следует отметить, что шифрование или криптографическое хеширование идентификатора сеанса следует рассматривать отдельно от транспортного шифрования, поскольку он защищен самим идентификатором сеанса, а не данными, которые он может представлять.

Если идентификатор сеанса может быть представлен злоумышленником приложению для получения доступа, он должен быть защищен в пути, чтобы снизить этот риск. Поэтому следует обеспечить, чтобы шифрование было как по умолчанию, так и для любого запроса или ответа, когда передается идентификатор сеанса, независимо от используемого механизма (например,., скрытое поле формы). Должны быть выполнены простые проверки, такие как замена `https: //` на `http: //` во время взаимодействия с приложением, вместе с модификацией постов формы, чтобы определить, реализована ли адекватная сегрегация между безопасным и незащищенным сайтами.

Обратите внимание, что если на сайте есть элемент, по которому пользователь отслеживается с помощью идентификаторов сеанса, но безопасность отсутствует (например,.отмечая, какие общедоступные документы загружает зарегистрированный пользователь), важно использовать другой идентификатор сеанса. Поэтому необходимо отслеживать идентификатор сеанса, когда клиент переключается с защищенных на незащищенные элементы, чтобы обеспечить использование другого.

> Каждый раз, когда аутентификация успешна, пользователь должен ожидать получения:
>
> - Другой жетон сеанса
> - Токен, отправляемый по зашифрованному каналу каждый раз, когда они делают HTTP-запрос

### Тестирование на прокси и уязвимости кэширования

Прокси также должны учитываться при проверке безопасности приложения. Во многих случаях клиенты получают доступ к приложению через корпоративные, интернет-провайдеры или другие прокси-серверы или шлюзы, осведомленные о протоколе (например,., Брандмауэры). Протокол HTTP содержит директивы для контроля поведения прокси-серверов, находящихся ниже по течению, и следует также оценить правильную реализацию этих директив.

В общем, идентификатор сеанса никогда не должен отправляться по незашифрованной транспортировке и никогда не должен кэшироваться. Приложение должно быть проверено, чтобы гарантировать, что зашифрованные сообщения являются как стандартными, так и принудительными для любой передачи идентификаторов сеанса. Кроме того, всякий раз, когда передается идентификатор сессии, должны быть предусмотрены директивы для предотвращения ее кэширования промежуточными и даже локальными кешами.

Приложение также должно быть настроено для защиты данных в кэшах по HTTP / 1.0 и HTTP / 1.1 - RFC 2616 обсуждает соответствующие элементы управления со ссылкой на HTTP. HTTP / 1.1 предоставляет ряд механизмов управления кэшем. `Cache-Control: no-cache` указывает, что прокси-сервер не должен повторно использовать какие-либо данные. Хотя «Cache-Control: Private» представляется подходящей директивой, она по-прежнему позволяет не совместному прокси-серверу кэшировать данные. В случае веб-кафе или других общих систем это представляет явный риск. Даже с однопользовательскими рабочими станциями кэшированный идентификатор сеанса может быть раскрыт путем компрометации файловой системы или использования сетевых хранилищ. Кэши HTTP / 1.0 не распознают директиву `Cache-Control: no-cache`.

> Директивы `Expires: 0` и `Cache-Control: max-age = 0` должны использоваться для дальнейшего обеспечения того, чтобы кэши не раскрывали данные. Каждый запрос / ответ, передающий данные Session ID, должен быть проверен, чтобы убедиться, что используются соответствующие директивы кэша.

### Тестирование на уязвимости GET & POST

Как правило, запросы GET не должны использоваться, так как идентификатор сеанса может быть раскрыт в журналах прокси или брандмауэра. Им также гораздо легче манипулировать, чем другими видами транспорта, хотя следует отметить, что клиент может манипулировать практически любым механизмом с помощью правильных инструментов. Кроме того, [Cross-site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/) атаки легче всего использовать, посылая специально построенную ссылку жертве. Это гораздо менее вероятно, если данные отправляются от клиента в виде POST.

Весь код на стороне сервера, получающий данные из запросов POST, должен быть проверен, чтобы убедиться, что он не принимает данные, если они отправлены как GET. Например, рассмотрим следующий запрос POST (`http://owaspapp.com/login.asp`) генерируется путем входа в систему.

```http
POST /login.asp HTTP/1.1
Host: owaspapp.com
[...]
Cookie: ASPSESSIONIDABCDEFG=ASKLJDLKJRELKHJG
Content-Length: 51

Login=Username&password=Password&SessionID=12345678
```

Если login.asp плохо реализован, возможно, можно войти в систему, используя следующий URL: `http://owaspapp.com/login.asp?Login=Username&password=Password&SessionID=12345678`

Потенциально небезопасные сценарии на стороне сервера могут быть идентифицированы путем проверки каждого POST таким образом.

### Тестирование на уязвимости транспорта

Все взаимодействие между Клиентом и Приложением должно быть проверено, по крайней мере, по следующим критериям.

- Как передаются идентификаторы сеанса? например., GET, POST, Form Field (включая скрытые поля)
- Идентификаторы сеанса всегда отправляются по зашифрованной транспортировке по умолчанию?
- Можно ли манипулировать приложением, чтобы отправлять идентификаторы сеанса в незашифрованном виде? например.путем изменения HTTPS на HTTP?
- Какие директивы управления кэшем применяются к запросам / ответам, передающим идентификаторы сеанса?
- Эти директивы всегда присутствуют? Если нет, то где исключения?
- Используются ли запросы GET, включающие идентификатор сеанса?
- Если используется POST, можно ли его заменить GET?

## References

### Whitepapers

- [RFCs 2109 & 2965 – HTTP State Management Mechanism [D. Kristol, L. Montulli]](https://www.ietf.org/rfc/rfc2965.txt)
- [RFC 2616 – Hypertext Transfer Protocol - HTTP/1.1](https://www.ietf.org/rfc/rfc2616.txt)
